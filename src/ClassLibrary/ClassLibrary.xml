<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ClassLibrary</name>
    </assembly>
    <members>
        <member name="T:Ucu.Poo.Locations.Client.Distance">
            <summary>
            Representa la distancia entre las coordenas o las direcciones de origen y destino retornada en los métodos
            <see cref="M:Ucu.Poo.Locations.Client.LocationApiClient.GetDistanceAsync(Ucu.Poo.Locations.Client.Location,Ucu.Poo.Locations.Client.Location)"/> o
            <see cref="M:Ucu.Poo.Locations.Client.LocationApiClient.GetDistanceAsync(System.String,System.String)"/>.
            </summary>
        </member>
        <member name="P:Ucu.Poo.Locations.Client.Distance.Found">
            <summary>
            Obtiene o establece un valor que indica si se encontraron o no las coordenas o las direcciones de origen y
            destino.
            </summary>
            <value>true si se encontró la dirección; false en caso contrario.</value>
        </member>
        <member name="P:Ucu.Poo.Locations.Client.Distance.TravelDistance">
            <summary>
            Obtiene o establece la distancia entre las coordenadas o las direcciones de origen y destino.
            </summary>
            <value>La distancia en metros.</value>
        </member>
        <member name="P:Ucu.Poo.Locations.Client.Distance.TravelDuration">
            <summary>
            Obtiene o establece el tiempo que se demora en llegar de las coordenadas o de las direcciones de origen a las de destino.
            </summary>
            <value>El tiempo que se demora en minutos.</value>
        </member>
        <member name="T:Ucu.Poo.Locations.Client.Location">
            <summary>
            Representa las coordenadas y otros datos de la ubicación de una dirección retornada en el método
            <see cref="M:Ucu.Poo.Locations.Client.LocationApiClient.GetLocationAsync(System.String,System.String,System.String,System.String)"/>.
            </summary>
        </member>
        <member name="P:Ucu.Poo.Locations.Client.Location.Found">
            <summary>
            Obtiene o establece un valor que indica si se encontró o no la dirección. En ese caso son válidos los demás
            valores. En caso contrario los demás valores son indeterminados.
            </summary>
            <value>true si se encontró la dirección; false en caso contrario.</value>
        </member>
        <member name="P:Ucu.Poo.Locations.Client.Location.AddresLine">
            <summary>
            Obtiene o establece la dirección: calle y número, ruta y kilómetro, etc.
            </summary>
            <value>Por ejemplo, Avenida 8 de Octubre 2738.</value>
        </member>
        <member name="P:Ucu.Poo.Locations.Client.Location.CountryRegion">
            <summary>
            Obtiene o establece el país.
            </summary>
            <value>Por ejemplo, Uruguay.</value>
        </member>
        <member name="P:Ucu.Poo.Locations.Client.Location.FormattedAddress">
            <summary>
            Obtiene o establece la dirección completa, incluyendo ciudad, código postal, etc.
            </summary>
            <value>Por ejemplo, Avenida 8 de Octubre 2738, Montevideo, 11200, Uruguay.</value>
        </member>
        <member name="P:Ucu.Poo.Locations.Client.Location.Locality">
            <summary>
            Obtiene o establece la localidad o ciudad.
            </summary>
            <value>Por ejemplo, Montevideo.</value>
        </member>
        <member name="P:Ucu.Poo.Locations.Client.Location.PostalCode">
            <summary>
            Obtiene o establece el código postal.
            </summary>
            <value>Por ejemplo, 11200.</value>
        </member>
        <member name="P:Ucu.Poo.Locations.Client.Location.Latitude">
            <summary>
            Obtiene o establece la latitud de la dirección.
            </summary>
            <value>El valor de la latitud en formato decimal.</value>
        </member>
        <member name="P:Ucu.Poo.Locations.Client.Location.Longitude">
            <summary>
            Obtiene o establece la longitud de la dirección.
            </summary>
            <value>El valor de la longitud en formato decimal.</value>
        </member>
        <member name="T:Ucu.Poo.Locations.Client.LocationApiClient">
            <summary>
            Un cliente de la API de localización.
            </summary>
        </member>
        <member name="M:Ucu.Poo.Locations.Client.LocationApiClient.GetLocationAsync(System.String,System.String,System.String,System.String)">
            <summary>
            Obtiene las coordenadas de una dirección.
            </summary>
            <param name="address">La dirección.</param>
            <param name="city">La ciudad. Es opcional. El valor predeterminado es Montevideo.</param>
            <param name="department">El departamento, estado, provincia, etc. Es opcional. El valor predeterminado es `ontevideo.</param>
            <param name="country">El país. Es opcional. El valor predeterminado es Uruguay.</param>
            <returns>Las coordenadas de la dirección.</returns>
        </member>
        <member name="M:Ucu.Poo.Locations.Client.LocationApiClient.GetLocation(System.String,System.String,System.String,System.String)">
            <inheritdoc cref="M:Ucu.Poo.Locations.Client.LocationApiClient.GetLocationAsync(System.String,System.String,System.String,System.String)" />
            <remarks>
            Versión sincrónica.
            </remarks>
        </member>
        <member name="M:Ucu.Poo.Locations.Client.LocationApiClient.GetDistanceAsync(Ucu.Poo.Locations.Client.Location,Ucu.Poo.Locations.Client.Location)">
            <summary>
            Obtiene la distancia entre dos coordenadas.
            </summary>
            <param name="from">La coordenada de origen.</param>
            <param name="to">La coordenada de destino.</param>
            <returns>La distancia entre las dos coordenadas.</returns>
        </member>
        <member name="M:Ucu.Poo.Locations.Client.LocationApiClient.GetDistance(Ucu.Poo.Locations.Client.Location,Ucu.Poo.Locations.Client.Location)">
            <inheritdoc cref="M:Ucu.Poo.Locations.Client.LocationApiClient.GetDistanceAsync(Ucu.Poo.Locations.Client.Location,Ucu.Poo.Locations.Client.Location)" />
            <remarks>
            Versión sincrónica.
            </remarks>
        </member>
        <member name="M:Ucu.Poo.Locations.Client.LocationApiClient.GetDistanceAsync(System.String,System.String)">
            <summary>
            Obtiene la distancia entre dos direcciones.
            </summary>
            <param name="from">La dirección de origen.</param>
            <param name="to">La dirección de destino.</param>
            <returns>La distancia entre las dos direcciones.</returns>
        </member>
        <member name="M:Ucu.Poo.Locations.Client.LocationApiClient.GetDistance(System.String,System.String)">
            <inheritdoc cref="M:Ucu.Poo.Locations.Client.LocationApiClient.GetDistanceAsync(System.String,System.String)" />.
            <remarks>
            Versión sincrónica.
            </remarks>
        </member>
        <member name="M:Ucu.Poo.Locations.Client.LocationApiClient.DownloadMapAsync(System.Double,System.Double,System.String,System.Int32)">
            <summary>
            Descarga una mapa de una coordenada.
            </summary>
            <param name="latitude">La latitud de la coordenada.</param>
            <param name="longitude">La longitud de la coordenada.</param>
            <param name="path">La ruta del archivo donde guardar el mapa. El formato es PNG.</param>
            <param name="zoomLevel">El nivel de zoom del mapa entre 1 y 20. Es opcional. El valor predeterminado es
            15.</param>
            <returns>
            Una tarea que representa la operación asincrónica.
            </returns>
        </member>
        <member name="M:Ucu.Poo.Locations.Client.LocationApiClient.DownloadMap(System.Double,System.Double,System.String,System.Int32)">
            <inheritdoc cref="M:Ucu.Poo.Locations.Client.LocationApiClient.DownloadMapAsync(System.Double,System.Double,System.String,System.Int32)" />.
            <remarks>
            Versión sincrónica.
            </remarks>
        </member>
        <member name="M:Ucu.Poo.Locations.Client.LocationApiClient.DownloadRouteAsync(System.Double,System.Double,System.Double,System.Double,System.String)">
            <summary>
            Un mapa con una ruta entre dos coordenadas.
            </summary>
            <param name="fromLatitude">La latitud de la coordenada de origen.</param>
            <param name="fromLongitude">La longitu de la coordenada de origen.</param>
            <param name="toLatitude">La latitud de la coordenada de destino.</param>
            <param name="toLongitude">La longitud de la coordenada de destino.</param>
            <param name="path">La ruta del archivo donde guardar el mapa. Es formato es PNG.</param>
            <returns>
            Una tarea que representa la operación asincrónica.
            </returns>
        </member>
        <member name="M:Ucu.Poo.Locations.Client.LocationApiClient.DownloadRoute(System.Double,System.Double,System.Double,System.Double,System.String)">
            <inheritdoc cref="M:Ucu.Poo.Locations.Client.LocationApiClient.DownloadRouteAsync(System.Double,System.Double,System.Double,System.Double,System.String)" />
            <remarks>
            Versión sincrónica.
            </remarks>
        </member>
        <member name="M:Ucu.Poo.Locations.Client.LocationApiClient.Dispose">
            <inheritdoc cref="T:System.IDisposable" />
        </member>
        <member name="M:Ucu.Poo.Locations.Client.LocationApiClient.Dispose(System.Boolean)">
            <inheritdoc cref="T:System.IDisposable" />
        </member>
        <member name="T:ClassLibrary.ContactWorkerCommand">
            <summary>
            Comando encargado de hacer el contacto entre un empleador y un empleado,
            haciendo referencia a que quiere contratarlo para un servicio en particular.
            
            Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación). 
            </summary>
        </member>
        <member name="P:ClassLibrary.ContactWorkerCommand.Name">
            <summary>
            Es el nombre que tendrá el comando y que lo diferenciará de otros comandos
            </summary>
            <value>El nombre que se le especifique</value>
        </member>
        <member name="P:ClassLibrary.ContactWorkerCommand.InProccess">
            <summary>
            Propiedad de solo lectura, compartida por el tipo ICommand, para que se sepa 
            si el comando se esta ejecutando (en cualquiera de sus pasos),  o si ya termino y 
            se puede pasar a otro.
            </summary>
            <value>true si todavía se esta ejecutando, false si ya termino o no ha empezado</value>/
        </member>
        <member name="P:ClassLibrary.ContactWorkerCommand.State">
            <summary>
            Propiedad que guía al propio comando en que paso debe estar ahora, y a sabiendas de eso, hace algo.
            El valor por defecto es que no inicio el comando, NoStarted
            </summary>
            <value></value>
        </member>
        <member name="F:ClassLibrary.ContactWorkerCommand.stateForUser">
            <summary>
            Diccionario que guarda el userID de cada usuario que ha ejecutado el comando y le guarda el estado en el que 
            quedo por última vez, así no se pisa entre la entrada de uno y la otra.
            </summary>
            <returns></returns>
        </member>
        <member name="F:ClassLibrary.ContactWorkerCommand.data">
            <summary>
            Los datos  para un usuario que va obteniendo el comando en los diferentes estados.
            </summary>
        </member>
        <member name="M:ClassLibrary.ContactWorkerCommand.#ctor">
            <summary>
            Se encarga de asignarle un valor a la propiedad del nombre con el fin
            de diferenciar entre un comando y otro.
            </summary>
        </member>
        <member name="M:ClassLibrary.ContactWorkerCommand.Cancel(System.Int64)">
            <summary>
            Cancela la ejecución del comando
            </summary>
            <returns>Mensaje con el nombre del comando a modo de confirmación de que se 
            cancelo el comando</returns>
        </member>
        <member name="M:ClassLibrary.ContactWorkerCommand.RestoreData(System.Int64)">
            <summary>
            Se encarga de resturar los datos que genero el comando cuando entro el user la vez pasada o en otra oportunidad
            Si es la primera vez que entra, lo pone en el diccionario
            </summary>
            <param name="userID">ID del usuario de Telegram</param>
        </member>
        <member name="M:ClassLibrary.ContactWorkerCommand.ProfileCanExecute(System.Int64)">
            <summary>
            Revisa si es un employer, si es employer y no otro puede ejecutar este comando
            </summary>
            <param name="userID">Identificador de Telegram del usuario que ejecuto el comando</param>
            <returns>True si puede, false si no esta habilitado</returns>
        </member>
        <member name="M:ClassLibrary.ContactWorkerCommand.Execute(System.Int64,System.String)">
            <summary>
            Este método permite que el employer envie un "mensaje", para así presentarse ante un worker, esto con la intención de 
            contratarlo para un servico en particular. Por eso es que se toma en cuenta la workOffer, ya que el employer quiere contactar
            al worker por esa oferta.
            </summary>
            <param name="userID"> Identificador del usuario que ejecuta el comando</param>
            <param name="inputData"> Los datos que tiene que llegarle al comando</param>
            <returns> Mensaje de si se ha podido enviarle su mensaje o solicitud de contacto al worker</returns>
        </member>
        <member name="T:ClassLibrary.ContactWorkerCommand.ContactWorkerState">
            <summary>
            Lista de los estados en los que puede estar este comando. La información se pide
            en el estado anterior, es decir, empieza a pedir información al usuario cuando esta en NoStarted
             pero con el InProcess en true, y así sucesivamente. 
            </summary>
        </member>
        <member name="F:ClassLibrary.ContactWorkerCommand.ContactWorkerState.Started">
            Recoje y procesa el supuesto identify de la workoffer que le interesa. En caso no ser correcta
            le pide que la ingrese de nuevo
        </member>
        <member name="F:ClassLibrary.ContactWorkerCommand.ContactWorkerState.NoStarted">
            Se da por terminado el comando o cuando no ha arrancado. En caso de no haber iniciado
            se pide el id de la oferta de trabajo que tiene el dueño que se quiere contactar. 
        </member>
        <member name="T:ClassLibrary.ContactWorkerCommand.ContactWorkerData">
            <summary>
            Representa los datos que va obteniendo el comando ContactWorkerCommand en los diferentes estados.
            </summary>
        </member>
        <member name="P:ClassLibrary.ContactWorkerCommand.ContactWorkerData.WorkOfferID">
            <summary>
            El precio que se ingresó en el estado ContactWorkerState.PricePromt.
            </summary>
        </member>
        <member name="P:ClassLibrary.ContactWorkerCommand.ContactWorkerData.Response">
            <summary>
            Resuesta que se guarda en cada paso que se va haciendo, así si entra otro usuario a ejecutar el comando, no se pierde lo que se 
            le había dicho a ese en particular
            </summary>
            <value></value>
        </member>
        <member name="T:ClassLibrary.CreateCategoryCommand">
            <summary>
            Comando encargado de crear una categoría.
            Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            /// Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            </summary>
        </member>
        <member name="P:ClassLibrary.CreateCategoryCommand.Name">
            <summary>
            Es el nombre que tendrá el comando y que lo diferenciará de otros comandos
            </summary>
            <value>El nombre que se le especifique</value>
        </member>
        <member name="P:ClassLibrary.CreateCategoryCommand.State">
            <summary>
            Propiedad que guía al propio comando en que paso debe estar ahora, y a sabiendas de eso, hace algo.
            El valor por defecto es que no inicio el comando, NoStarted
            </summary>
            <value></value>
        </member>
        <member name="F:ClassLibrary.CreateCategoryCommand.stateForUser">
            <summary>
            Diccionario que guarda el userID de cada usuario que ha ejecutado el comando y le guarda el estado en el que 
            quedo por última vez, así no se pisa entre la entrada de uno y la otra.
            </summary>
            <returns></returns>
        </member>
        <member name="F:ClassLibrary.CreateCategoryCommand.data">
            <summary>
            Los datos  para un usuario que va obteniendo el comando en los diferentes estados.
            </summary>
        </member>
        <member name="P:ClassLibrary.CreateCategoryCommand.InProccess">
            <summary>
            Propiedad de solo lectura, compartida por el tipo ICommand, para que se sepa 
            si el comando se esta ejecutando (en cualquiera de sus pasos),  o si ya termino y 
            se puede pasar a otro.
            </summary>
            <value>true si todavía se esta ejecutando, false si ya termino o no ha empezado</value>/
        </member>
        <member name="M:ClassLibrary.CreateCategoryCommand.#ctor">
            <summary>
            Se encarga de asignarle un valor a la propiedad del nombre con el fin
            de diferenciar entre un comando y otro.
            </summary>
        </member>
        <member name="M:ClassLibrary.CreateCategoryCommand.Cancel(System.Int64)">
            <summary>
            Cancela la ejecución del comando
            </summary>
            <returns>Mensaje con el nombre del comando a modo de confirmación de que se 
            cancelo el comando</returns>
        </member>
        <member name="M:ClassLibrary.CreateCategoryCommand.RestoreData(System.Int64)">
            <summary>
            Se encarga de resturar los datos que genero el comando cuando entro el user la vez pasada o en otra oportunidad
            Si es la primera vez que entra, lo pone en el diccionario
            </summary>
            <param name="userID">ID del usuario de Telegram</param>
        </member>
        <member name="M:ClassLibrary.CreateCategoryCommand.ProfileCanExecute(System.Int64)">
            <summary>
            Revisa si es un admin, si es admin y no otro puede ejecutar este comando
            </summary>
            <param name="userID">Identificador de Telegram del usuario que ejecuto el comando</param>
            <returns>True si puede, false si no esta habilitado</returns>
        </member>
        <member name="M:ClassLibrary.CreateCategoryCommand.Execute(System.Int64,System.String)">
            <summary>
            Operación polimorfica que le solicita al usuario (admin), que ingrese el nombre de la categoría que quiere crear,
            de tener un formato adecuado lo crea y le devuelve un mensaje de confirmación. En caso de que no le vuelve a pedir la 
            información. 
            </summary>
            <param name="userID"> Identificador del usuario que ejecuta el comando</param>
            <param name="inputData"> Los datos que tiene que llegarle al comando</param>
            <returns> Mensaje de que paso en cada paso de la ejecución del comando</returns>
        </member>
        <member name="T:ClassLibrary.CreateCategoryCommand.CreateCategoryState">
            <summary>
            Lista de los estados en los que puede estar este comando. La información se pide
            en el estado anterior, es decir, empieza a pedir información al usuario cuando esta en NoStarted
             pero con el InProcess en true, y así sucesivamente. 
            </summary>
        </member>
        <member name="F:ClassLibrary.CreateCategoryCommand.CreateCategoryState.NoStarted">
             Para cuando no se ha iniciado el comando o se detuvo. Cuando no ha iniciado y pasa a estar InProcess en tru
            pide el nombre de la categoría a crear.
        </member>
        <member name="F:ClassLibrary.CreateCategoryCommand.CreateCategoryState.Started">
            Recoje el nombre de la catogría pedido al inicio cuando "prende" el comando
        </member>
        <member name="T:ClassLibrary.CreateCategoryCommand.CategoryData">
            <summary>
            Representa los datos que va obteniendo el comando CreateCategoryCommand en los diferentes estados.
            </summary>
        </member>
        <member name="P:ClassLibrary.CreateCategoryCommand.CategoryData.Name">
            <summary>
            El nombre que se ingresó en la primer entrada del comando.
            </summary>
        </member>
        <member name="P:ClassLibrary.CreateCategoryCommand.CategoryData.Response">
            <summary>
            La respuesta a dar al usuario.
            </summary>
        </member>
        <member name="T:ClassLibrary.CreateWorkOfferCommand">
            <summary>
            Comando encargado de crear una oferta de trabajo con los datos que se le van pasando. 
            También controla si sos uno de los user habilitados para hacer uso de este comando, como el resto de clases concretas
            que implementan el tipo ICommand.
            
            Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            /// Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            </summary>
        </member>
        <member name="P:ClassLibrary.CreateWorkOfferCommand.Name">
            <summary>
            Es el nombre que tendrá el comando y que lo diferenciará de otros comandos
            </summary>
            <value>El nombre que se le especifique</value>
        </member>
        <member name="P:ClassLibrary.CreateWorkOfferCommand.State">
            <summary>
            Propiedad que guía al propio comando en que paso debe estar ahora, y a sabiendas de eso, hace algo.
            El valor por defecto es que no inicio el comando, NoStarted
            </summary>
            <value></value>
        </member>
        <member name="F:ClassLibrary.CreateWorkOfferCommand.stateForUser">
            <summary>
            Diccionario que guarda el userID de cada usuario que ha ejecutado el comando y le guarda el estado en el que 
            quedo por última vez, así no se pisa entre la entrada de uno y la otra.
            </summary>
            <returns></returns>
        </member>
        <member name="F:ClassLibrary.CreateWorkOfferCommand.data">
            <summary>
            Los datos  para un usuario que va obteniendo el comando en los diferentes estados.
            </summary>
        </member>
        <member name="P:ClassLibrary.CreateWorkOfferCommand.InProccess">
            <summary>
            Propiedad de solo lectura, compartida por el tipo ICommand, para que se sepa 
            si el comando se esta ejecutando (en cualquiera de sus pasos),  o si ya termino y 
            se puede pasar a otro.
            </summary>
            <value>true si todavía se esta ejecutando, false si ya termino o no ha empezado</value>/
        </member>
        <member name="M:ClassLibrary.CreateWorkOfferCommand.#ctor">
            <summary>
            Se encarga de asignarle un valor a la propiedad del nombre con el fin
            de diferenciar entre un comando y otro
            </summary>
        </member>
        <member name="M:ClassLibrary.CreateWorkOfferCommand.Cancel(System.Int64)">
            <summary>
            Cancela la ejecución del comando
            </summary>
            <returns>Mensaje con el nombre del comando a modo de confirmación de que se 
            cancelo el comando</returns>
        </member>
        <member name="M:ClassLibrary.CreateWorkOfferCommand.RestoreData(System.Int64)">
            <summary>
            Se encarga de resturar los datos que genero el comando cuando entro el user la vez pasada o en otra oportunidad
            Si es la primera vez que entra, lo pone en el diccionario
            </summary>
            <param name="userID">ID del usuario de Telegram</param>
        </member>
        <member name="M:ClassLibrary.CreateWorkOfferCommand.ProfileCanExecute(System.Int64)">
            <summary>
            Revisa si es un worker, si es worker y no otro puede ejecutar este comando
            </summary>
            <param name="userID">Identificador de Telegram del usuario que ejecuto el comando</param>
            <returns>True si puede, false si no esta habilitado</returns>
        </member>
        <member name="M:ClassLibrary.CreateWorkOfferCommand.Execute(System.Int64,System.String)">
            <summary>
            Operación polimorfica que le solicita al usuario (worker), que ingrese los diferentes datos necesarios para crear una oferta de trabajo.
            Si estan bien esos datos desde un principio, cambia al siguiente paso, de no ser así, permanece ahí y vuelve a pedir la inforamción que 
            se ingresó mal. Finalmente, si esta todo bien y no se cancelo antes, crea una oferta de trabajo, con la información especificada. 
            </summary>
            <param name="userID"> Identificador del usuario que ejecuta el comando</param>
            <param name="inputData"> Los datos que tiene que llegarle al comando</param>
            <returns> Mensaje de que paso en cada paso de la ejecución del comando</returns>
        </member>
        <member name="T:ClassLibrary.CreateWorkOfferCommand.CreateWorkOfferState">
            <summary>
            Lista de los estados en los que puede estar este comando. La información se pide
            en el estado anterior, es decir, empieza a pedir información al usuario cuando esta en NoStarted
             pero con el InProcess en true, y así sucesivamente. 
            </summary>
        </member>
        <member name="F:ClassLibrary.CreateWorkOfferCommand.CreateWorkOfferState.NoStarted">
            Para cuando no se ha iniciado el comando o se detuvo. Si no se ha iniciado y se pasa el InProcess a true,
            se le pide el primer dato, la descripción de la oferta
        </member>
        <member name="F:ClassLibrary.CreateWorkOfferCommand.CreateWorkOfferState.Started">
            Cuando se inicio el comando, y recoje el dato pedido cuando paso a estar "prendido": la despcrpción.
        </member>
        <member name="F:ClassLibrary.CreateWorkOfferCommand.CreateWorkOfferState.CurrencyPromt">
            Cuando el comando recoje la moneda a usar
        </member>
        <member name="F:ClassLibrary.CreateWorkOfferCommand.CreateWorkOfferState.PricePromt">
            Cuando el comando recoje el precio
        </member>
        <member name="F:ClassLibrary.CreateWorkOfferCommand.CreateWorkOfferState.CategoriesPromt">
            Cuando el comando recoje la o las categorías
        </member>
        <member name="F:ClassLibrary.CreateWorkOfferCommand.CreateWorkOfferState.DurationInDaysPromt">
            Cuando el comando recoje la cantidad de días que dura la oferta
        </member>
        <member name="T:ClassLibrary.CreateWorkOfferCommand.WorkOfferData">
            <summary>
            Representa los datos que va obteniendo el comando CreateWorkOfferCommand en los diferentes estados.
            </summary>
        </member>
        <member name="P:ClassLibrary.CreateWorkOfferCommand.WorkOfferData.Description">
            <summary>
            La descripción que se ingresó en el estado CreateWorkOfferState.Started.
            </summary>
        </member>
        <member name="P:ClassLibrary.CreateWorkOfferCommand.WorkOfferData.Currency">
            <summary>
            La moneda que se ingresó en el estado CreateWorkOfferState.CurrencyPromt.
            </summary>
        </member>
        <member name="P:ClassLibrary.CreateWorkOfferCommand.WorkOfferData.Price">
            <summary>
            El precio que se ingresó en el estado CreateWorkOfferState.PricePromt.
            </summary>
        </member>
        <member name="F:ClassLibrary.CreateWorkOfferCommand.WorkOfferData.Categories">
            <summary>
            Las categorías ingresadas en el estado CreateWorkOfferState.CategoriesPromt.
            </summary>
        </member>
        <member name="P:ClassLibrary.CreateWorkOfferCommand.WorkOfferData.DurationInDays">
            <summary>
            La duración del trabajo que se ingresó en el estado CreateWorkOfferState.DurationInDaysPromt.
            </summary>
        </member>
        <member name="P:ClassLibrary.CreateWorkOfferCommand.WorkOfferData.Response">
            <summary>
            Resuesta que se guarda en cada paso que se va haciendo, así si entra otro usuario a ejecutar el comando, no se pierde lo que se 
            le había dicho a ese en particular
            </summary>
            <value></value>
        </member>
        <member name="T:ClassLibrary.DeleteWorkOfferCommand">
            <summary>
            Comando encargado de eliminar las ofertas de trabajo
            
            Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            /// Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            </summary>
        </member>
        <member name="P:ClassLibrary.DeleteWorkOfferCommand.Name">
            <summary>
            Es el nombre que tendrá el comando y que lo diferenciará de otros comandos
            </summary>
            <value>El nombre que se le especifique</value>
        </member>
        <member name="P:ClassLibrary.DeleteWorkOfferCommand.State">
            <summary>
            Propiedad que guía al propio comando en que paso debe estar ahora, y a sabiendas de eso, hace algo.
            El valor por defecto es que no inicio el comando, NoStarted
            </summary>
            <value></value>
        </member>
        <member name="F:ClassLibrary.DeleteWorkOfferCommand.stateForUser">
            <summary>
            Diccionario que guarda el userID de cada usuario que ha ejecutado el comando y le guarda el estado en el que 
            quedo por última vez, así no se pisa entre la entrada de uno y la otra.
            </summary>
            <returns></returns>
        </member>
        <member name="F:ClassLibrary.DeleteWorkOfferCommand.data">
            <summary>
            Los datos  para un usuario que va obteniendo el comando en los diferentes estados.
            </summary>
        </member>
        <member name="P:ClassLibrary.DeleteWorkOfferCommand.InProccess">
            <summary>
            Propiedad de solo lectura, compartida por el tipo ICommand, para que se sepa 
            si el comando se esta ejecutando (en cualquiera de sus pasos),  o si ya termino y 
            se puede pasar a otro.
            </summary>
            <value>true si todavía se esta ejecutando, false si ya termino o no ha empezado</value>/
        </member>
        <member name="M:ClassLibrary.DeleteWorkOfferCommand.#ctor">
            <summary>
            Se encarga de asignarle un valor a la propiedad del nombre con el fin
            de diferenciar entre un comando y otro
            </summary>
        </member>
        <member name="M:ClassLibrary.DeleteWorkOfferCommand.Cancel(System.Int64)">
            <summary>
            Cancela la ejecución del comando
            </summary>
            <returns>Mensaje con el nombre del comando a modo de confirmación de que se 
            cancelo el comando</returns>
        </member>
        <member name="M:ClassLibrary.DeleteWorkOfferCommand.ProfileCanExecute(System.Int64)">
            <summary>
            Revisa si es un admin, si es admin y no otro puede ejecutar este comando
            </summary>
            <param name="userID">Identificador de Telegram del usuario que ejecuto el comando</param>
            <returns>True si puede, false si no esta habilitado</returns>
        </member>
        <member name="M:ClassLibrary.DeleteWorkOfferCommand.RestoreData(System.Int64)">
            <summary>
            Se encarga de resturar los datos que genero el comando cuando entro el user la vez pasada o en otra oportunidad
            Si es la primera vez que entra, lo pone en el diccionario
            </summary>
            <param name="userID">ID del usuario de Telegram</param>
        </member>
        <member name="M:ClassLibrary.DeleteWorkOfferCommand.Execute(System.Int64,System.String)">
            <summary>
            Operación polimorfica que le solicita al usuario (admin), que ingrese el identificador de la oferta que quiere borrar
            Si esta bien elimina la oferta, sino le avisa y espera a que este bien para ejecutar el comportamiento, a menos que se cancele
            su ejecución antes. 
            </summary>
            <param name="userID"> Identificador del usuario que ejecuta el comando</param>
            <param name="inputData"> Los datos que tiene que llegarle al comando</param>
            <returns> Mensaje de que paso en cada paso de la ejecución del comando</returns>
        </member>
        <member name="T:ClassLibrary.DeleteWorkOfferState">
            <summary>
            Lista de los estados en los que puede estar este comando. La información se pide
            en el estado anterior, es decir, empieza a pedir información al usuario cuando esta en NoStarted
             pero con el InProcess en true, y así sucesivamente. 
            </summary>
        </member>
        <member name="F:ClassLibrary.DeleteWorkOfferState.NoStarted">
            Para cuando no se ha iniciado el comando o se detuvo. 
            Si no se había iniciado y ahora InProccess pasa a estar en true, se pide el
            identificador de la oferta de trabajo
        </member>
        <member name="F:ClassLibrary.DeleteWorkOfferState.Started">
            Cuando recoje el id de la oferta de trabajo que se quiere eliminar
        </member>
        <member name="T:ClassLibrary.DeletedData">
            <summary>
            Representa los datos que va obteniendo el comando en los diferentes estados del comando.
            </summary>
        </member>
        <member name="P:ClassLibrary.DeletedData.IDToDelete">
            <summary>
            El ID de la oferta de trabajo que se ingresó en la primer entrada del comando.
            </summary>
        </member>
        <member name="P:ClassLibrary.DeletedData.Response">
            <summary>
            La respuesta a dar al usuario.
            </summary>
        </member>
        <member name="T:ClassLibrary.RateEmployerCommand">
            <summary>
            Comando que realiza la gestión para que un trabajador califique a un empleador.
            
             Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            /// Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            </summary>
        </member>
        <member name="P:ClassLibrary.RateEmployerCommand.Name">
            <summary>
            Nombre del comando, el que debe coincidir con la entrada que el usuario inserta al bot.
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.RateEmployerCommand.InProccess">
            <summary>
            Propiedad de solo lectura, compartida por el tipo ICommand, para que se sepa 
            si el comando se esta ejecutando (en cualquiera de sus pasos),  o si ya termino y 
            se puede pasar a otro.
            </summary>
            <value>true si todavía se esta ejecutando, false si ya termino o no ha empezado</value>/
        </member>
        <member name="M:ClassLibrary.RateEmployerCommand.#ctor">
            <summary>
            Constructor que determina el nombre del comando.
            </summary>
        </member>
        <member name="P:ClassLibrary.RateEmployerCommand.State">
            <summary>
            Propiedad que guía al propio comando en que paso debe estar ahora, y a sabiendas de eso, hace algo.
            El valor por defecto es que no inicio el comando, NoStarted
            </summary>
            <value></value>
        </member>
        <member name="F:ClassLibrary.RateEmployerCommand.stateForUser">
            <summary>
            Diccionario que guarda el userID de cada usuario que ha ejecutado el comando y le guarda el estado en el que 
            quedó por última vez, así no se pisa entre la entrada de uno y la otra.
            </summary>
            <returns></returns>
        </member>
        <member name="F:ClassLibrary.RateEmployerCommand.data">
            <summary>
            Los datos  para un usuario que va obteniendo el comando en los diferentes estados.
            </summary>
        </member>
        <member name="M:ClassLibrary.RateEmployerCommand.Cancel(System.Int64)">
            <summary>
            Cancela la ejecución del comando
            </summary>
            <returns>Mensaje con el nombre del comando a modo de confirmación de que se 
            cancelo el comando</returns>
        </member>
        <member name="M:ClassLibrary.RateEmployerCommand.RestoreData(System.Int64)">
            <summary>
            Se encarga de resturar los datos que genero el comando cuando entro el user la vez pasada o en otra oportunidad
            Si es la primera vez que entra, lo pone en el diccionario
            </summary>
        </member>
        <member name="M:ClassLibrary.RateEmployerCommand.ProfileCanExecute(System.Int64)">
            <summary>
            Revisa si es un worker, si es worker y no otro puede ejecutar este comando
            </summary>
            <param name="userID">Identificador de Telegram del usuario que ejecuto el comando</param>
            <returns>True si puede, false si no esta habilitado</returns>
        </member>
        <member name="M:ClassLibrary.RateEmployerCommand.Execute(System.Int64,System.String)">
            <summary>
            Operación polimorfica que le solicita al usuario (worker), que ingrese el identificador del employer
            al que se quiere calificar.
            </summary>
            <param name="userID"> Identificador del usuario que ejecuta el comando</param>
            <param name="inputData"> Los datos que tiene que llegarle al comando</param>
            <returns> Mensaje de que paso en cada paso de la ejecución del comando</returns>
        </member>
        <member name="T:ClassLibrary.RateEmployerCommand.RateEmployerState">
            <summary>
            Estados que puede tener el comando.
            </summary>
        </member>
        <member name="F:ClassLibrary.RateEmployerCommand.RateEmployerState.NoStarted">
            Para cuando no se ha iniciado el comando o se detuvo. 
            Si no se había iniciado y ahora InProccess pasa a estar en true, se pide el
            identificador del employer
        </member>
        <member name="F:ClassLibrary.RateEmployerCommand.RateEmployerState.Started">
            Cuando inicia el comando, recoje el id del que se quiere calificar, pedido en el paso anterior.
        </member>
        <member name="F:ClassLibrary.RateEmployerCommand.RateEmployerState.WorkOfferPromt">
            Pide Work Offer que relaciona al empleador y trabajador.
        </member>
        <member name="F:ClassLibrary.RateEmployerCommand.RateEmployerState.RatePromt">
            Pasa a pedir la calificación a enviar.
        </member>
        <member name="T:ClassLibrary.RateEmployerCommand.RateData">
            <summary>
            Representa los datos que va obteniendo el comando en los diferentes estados.
            </summary>
        </member>
        <member name="P:ClassLibrary.RateEmployerCommand.RateData.CalificatedEmployer">
            <summary>
            El empleador calificado.
            </summary>
        </member>
        <member name="P:ClassLibrary.RateEmployerCommand.RateData.Rate">
            <summary>
            La calificación a ingresar al empleador.
            </summary>
        </member>
        <member name="P:ClassLibrary.RateEmployerCommand.RateData.WorkOfferBased">
            <summary>
            En qué WorkOffer se basa para calificar.
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.RateEmployerCommand.RateData.Response">
            <summary>
            La respuesta a devolver al usuario.
            </summary>
            <value></value>
        </member>
        <member name="T:ClassLibrary.RateWorkerCommand">
            <summary>
            Comando que realiza la gestión para que un empleador califique a un trabajador
            
            Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            /// Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            </summary>
        </member>
        <member name="P:ClassLibrary.RateWorkerCommand.Name">
            <summary>
            Nombre del comando, el que debe coincidir con la entrada que el usuario inserta al bot.
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.RateWorkerCommand.InProccess">
            <summary>
            Propiedad de solo lectura, compartida por el tipo ICommand, para que se sepa 
            si el comando se esta ejecutando (en cualquiera de sus pasos),  o si ya termino y 
            se puede pasar a otro.
            </summary>
            <value>true si todavía se esta ejecutando, false si ya termino o no ha empezado</value>/
        </member>
        <member name="M:ClassLibrary.RateWorkerCommand.#ctor">
            <summary>
            Constructor que determina el nombre del comando.
            </summary>
        </member>
        <member name="P:ClassLibrary.RateWorkerCommand.State">
            <summary>
            Propiedad que guía al propio comando en que paso debe estar ahora, y a sabiendas de eso, hace algo.
            El valor por defecto es que no inicio el comando, NoStarted
            </summary>
            <value></value>
        </member>
        <member name="F:ClassLibrary.RateWorkerCommand.stateForUser">
            <summary>
            Diccionario que guarda el userID de cada usuario que ha ejecutado el comando y le guarda el estado en el que 
            quedó por última vez, así no se pisa entre la entrada de uno y la otra.
            </summary>
            <returns></returns>
        </member>
        <member name="F:ClassLibrary.RateWorkerCommand.data">
            <summary>
            Los datos  para un usuario que va obteniendo el comando en los diferentes estados.
            </summary>
        </member>
        <member name="M:ClassLibrary.RateWorkerCommand.Cancel(System.Int64)">
            <summary>
            Cancela la ejecución del comando
            </summary>
            <returns>Mensaje con el nombre del comando a modo de confirmación de que se 
            cancelo el comando</returns>
        </member>
        <member name="M:ClassLibrary.RateWorkerCommand.ProfileCanExecute(System.Int64)">
            <summary>
            Revisa si es un employer, si es employer y no otro puede ejecutar este comando
            </summary>
            <param name="userID">Identificador de Telegram del usuario que ejecuto el comando</param>
            <returns>True si puede, false si no esta habilitado</returns>
        </member>
        <member name="M:ClassLibrary.RateWorkerCommand.RestoreData(System.Int64)">
            <summary>
            Se encarga de resturar los datos que genero el comando cuando entro el user la vez pasada o en otra oportunidad
            Si es la primera vez que entra, lo pone en el diccionario
            </summary>
        </member>
        <member name="M:ClassLibrary.RateWorkerCommand.Execute(System.Int64,System.String)">
            <summary>
            Operación polimorfica que le solicita al usuario (employer), que ingrese el identificador del worker
            que se quiere calificar. 
            </summary>
            <param name="userID"> Identificador del usuario que ejecuta el comando</param>
            <param name="inputData"> Los datos que tiene que llegarle al comando</param>
            <returns> Mensaje de que paso en cada paso de la ejecución del comando</returns>
        </member>
        <member name="T:ClassLibrary.RateWorkerCommand.RateWorkerState">
            <summary>
            Estados que puede tener el comando
            </summary>
        </member>
        <member name="F:ClassLibrary.RateWorkerCommand.RateWorkerState.NoStarted">
            Para cuando no se ha iniciado el comando o se detuvo. 
            Si no se había iniciado y ahora InProccess pasa a estar en true, se pide el
            identificador del worker a calificar
        </member>
        <member name="F:ClassLibrary.RateWorkerCommand.RateWorkerState.Started">
            Cuando inicia el comando recoje el id del worker que se quiere calificar
            pedido en el paso anterior
        </member>
        <member name="F:ClassLibrary.RateWorkerCommand.RateWorkerState.RatePromt">
            Pasa a pedir la calificación a enviar
        </member>
        <member name="T:ClassLibrary.RateWorkerCommand.RateData">
            <summary>
            Representa los datos que va obteniendo el comando en los diferentes estados.
            </summary>
        </member>
        <member name="P:ClassLibrary.RateWorkerCommand.RateData.OwnerOfWorkOfferID">
            <summary>
            El ID del dueño de la oferta de trabajo.
            </summary>
        </member>
        <member name="P:ClassLibrary.RateWorkerCommand.RateData.Rate">
            <summary>
            La calificación a ingresar al trabajador.
            /// </summary>
        </member>
        <member name="P:ClassLibrary.RateWorkerCommand.RateData.CalificatedWorkOffer">
            <summary>
            La oferta de trabajo calificada.
            /// </summary>
        </member>
        <member name="P:ClassLibrary.RateWorkerCommand.RateData.Response">
            <summary>
            La respuesta a devolver al usuario.
            </summary>
            <value></value>
        </member>
        <member name="T:ClassLibrary.RegisterAsEmployerCommand">
            <summary>
            Comando necesario que realiza la gestión para que un usuario se registre como empleador.
            
            Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            /// Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            </summary>
        </member>
        <member name="P:ClassLibrary.RegisterAsEmployerCommand.Name">
            <summary>
            Nombre del comando, el que debe coincidir con la entrada que el usuario inserta al bot.
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.RegisterAsEmployerCommand.InProccess">
            <summary>
            Propiedad de solo lectura, compartida por el tipo ICommand, para que se sepa 
            si el comando se esta ejecutando (en cualquiera de sus pasos),  o si ya termino y 
            se puede pasar a otro.
            </summary>
            <value>true si todavía se esta ejecutando, false si ya termino o no ha empezado</value>/
        </member>
        <member name="M:ClassLibrary.RegisterAsEmployerCommand.#ctor">
            <summary>
            Constructor que determina el nombre del comando.
            También inicializa lo necesario para hacer uso de la APILocation
            </summary>
        </member>
        <member name="P:ClassLibrary.RegisterAsEmployerCommand.State">
            <summary>
            Propiedad que guía al propio comando en que paso debe estar ahora, y a sabiendas de eso, hace algo.
            El valor por defecto es que no inicio el comando, NoStarted
            </summary>
            <value></value>
        </member>
        <member name="F:ClassLibrary.RegisterAsEmployerCommand.stateForUser">
            <summary>
            Diccionario que guarda el userID de cada usuario que ha ejecutado el comando y le guarda el estado en el que 
            quedo por última vez, así no se pisa entre la entrada de uno y la otra.
            </summary>
            <returns></returns>
        </member>
        <member name="F:ClassLibrary.RegisterAsEmployerCommand.data">
            <summary>
            Los datos  para un usuario que va obteniendo el comando en los diferentes estados.
            </summary>
        </member>
        <member name="M:ClassLibrary.RegisterAsEmployerCommand.Cancel(System.Int64)">
            <summary>
            Cancela la ejecución del comando
            </summary>
            <returns>Mensaje con el nombre del comando a modo de confirmación de que se 
            cancelo el comando</returns>
        </member>
        <member name="M:ClassLibrary.RegisterAsEmployerCommand.RestoreData(System.Int64)">
            <summary>
            Se encarga de resturar los datos que genero el comando cuando entro el user la vez pasada o en otra oportunidad
            Si es la primera vez que entra, lo pone en el diccionario
            </summary>
            <param dataOfEmployer.Name="userID"></param>
        </member>
        <member name="M:ClassLibrary.RegisterAsEmployerCommand.ProfileCanExecute(System.Int64)">
            <summary>
            Revisa si no es un user del sistema debe poder usarlo
            </summary>
            <param name="userID">Identificador de Telegram del usuario que ejecuto el comando</param>
            <returns>True si puede, false si no esta habilitado</returns>
        </member>
        <member name="M:ClassLibrary.RegisterAsEmployerCommand.Execute(System.Int64,System.String)">
            <summary>
            Operación polimorifica que en este caso se encarga de ir tomando los datos necesarios 
            para registrar/crear un user como employer. Si los datos están mal lo obliga a ingresarlos bien
            o a cancelar el comando.
            </summary>
            <param name="userID"> Identificador del usuario que ejecuta el comando</param>
            <param name="inputData"> Los datos que tiene que llegarle al comando</param>
            <returns> Mensaje de que paso en cada paso de la ejecución del comando</returns>
        </member>
        <member name="T:ClassLibrary.RegisterAsEmployerCommand.RegisterAsEmployerState">
            <summary>
            Determina los estados que tiene el comando.
            </summary>
        </member>
        <member name="F:ClassLibrary.RegisterAsEmployerCommand.RegisterAsEmployerState.NoStarted">
            Para cuando no se ha iniciado el comando o se detuvo. 
            Si no se había iniciado y ahora InProccess pasa a estar en true, 
            se pide el nombre del usuario a registrarse. 
        </member>
        <member name="F:ClassLibrary.RegisterAsEmployerCommand.RegisterAsEmployerState.Started">
            Cuando inicia el comando y recoje el dato del nombre pedido en el paso anterior
        </member>
        <member name="F:ClassLibrary.RegisterAsEmployerCommand.RegisterAsEmployerState.LastNamePromt">
            Cuando el comando recoje el apellido
        </member>
        <member name="F:ClassLibrary.RegisterAsEmployerCommand.RegisterAsEmployerState.PhonePromt">
            Cuando el comando recoje el teléfono
        </member>
        <member name="F:ClassLibrary.RegisterAsEmployerCommand.RegisterAsEmployerState.FormatAddressLocation">
            Cuando el comando recoje el nombre de la ubicación
        </member>
        <member name="T:ClassLibrary.RegisterAsEmployerCommand.EmployerData">
            <summary>
            Representa los datos que va obteniendo el comando RegisterAsEmployerCommand en los diferentes estados.
            </summary>
        </member>
        <member name="P:ClassLibrary.RegisterAsEmployerCommand.EmployerData.Name">
            <summary>
            El nombre que se ingresó en el estado RegisterAsEmployerState.Started.
            </summary>
        </member>
        <member name="P:ClassLibrary.RegisterAsEmployerCommand.EmployerData.LastName">
            <summary>
            El apellido que se ingresó en el estado RegisterAsEmployerState.LastNameProm.
            /// </summary>
        </member>
        <member name="P:ClassLibrary.RegisterAsEmployerCommand.EmployerData.Phone">
            <summary>
            El número que se ingresó en el estado RegisterAsEmployerState.PhonePromt.
            /// </summary>
        </member>
        <member name="P:ClassLibrary.RegisterAsEmployerCommand.EmployerData.Result">
            <summary>
            Resultado de la busqueda, en objetos de tipo
             IAddressREsult se guerda la información de la ubicación,
            así como si fue encontrada o no. 
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.RegisterAsEmployerCommand.EmployerData.Address">
            <summary>
            La ubicación que se ingresó en el estado RegisterAsEmployerState.FormatAddressLocation.
            /// </summary>
        </member>
        <member name="P:ClassLibrary.RegisterAsEmployerCommand.EmployerData.FormattedAddress">
            <summary>
            Dirección formateada que es uno de los datos que devuelve el buscador de direcciones
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.RegisterAsEmployerCommand.EmployerData.Response">
            <summary>
            Resuesta que se guarda en cada paso que se va haciendo, así si entra otro usuario a ejecutar el comando, no se pierde lo que se 
            le había dicho a ese en particular
            </summary>
            <value></value>
        </member>
        <member name="T:ClassLibrary.RegisterAsWorkerCommand">
            <summary>
            Comando que realiza la gestión para que un usuario se registre como trabajador.
            
            Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            /// Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            </summary>
        </member>
        <member name="P:ClassLibrary.RegisterAsWorkerCommand.Name">
            <summary>
            Nombre del comando, el que debe coincidir con la entrada que el usuario inserta al bot.
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.RegisterAsWorkerCommand.InProccess">
            <summary>
            Propiedad de solo lectura, compartida por el tipo ICommand, para que se sepa 
            si el comando se esta ejecutando (en cualquiera de sus pasos),  o si ya termino y 
            se puede pasar a otro.
            </summary>
            <value>true si todavía se esta ejecutando, false si ya termino o no ha empezado</value>/
        </member>
        <member name="M:ClassLibrary.RegisterAsWorkerCommand.#ctor">
            <summary>
            Constructor que determina el nombre del comando.
            También inicializa lo necesario para hacer uso de la APILocation
            </summary>
        </member>
        <member name="P:ClassLibrary.RegisterAsWorkerCommand.State">
            <summary>
            Propiedad que guía al propio comando en que paso debe estar ahora, y a sabiendas de eso, hace algo.
            El valor por defecto es que no inicio el comando, NoStarted
            </summary>
            <value></value>
        </member>
        <member name="F:ClassLibrary.RegisterAsWorkerCommand.stateForUser">
            <summary>
            Diccionario que guarda el userID de cada usuario que ha ejecutado el comando y le guarda el estado en el que 
            quedo por última vez, así no se pisa entre la entrada de uno y la otra.
            </summary>
            <returns></returns>
        </member>
        <member name="F:ClassLibrary.RegisterAsWorkerCommand.data">
            <summary>
            Los datos  para un usuario que va obteniendo el comando en los diferentes estados.
            </summary>
        </member>
        <member name="M:ClassLibrary.RegisterAsWorkerCommand.Cancel(System.Int64)">
            <summary>
            Cancela la ejecución del comando
            </summary>
            <returns>Mensaje con el nombre del comando a modo de confirmación de que se 
            cancelo el comando</returns>
        </member>
        <member name="M:ClassLibrary.RegisterAsWorkerCommand.RestoreData(System.Int64)">
            <summary>
            Se encarga de resturar los datos que genero el comando cuando entro el user la vez pasada o en otra oportunidad
            Si es la primera vez que entra, lo pone en el diccionario
            </summary>
            <param dataOfWorker.Name="userID"></param>
        </member>
        <member name="M:ClassLibrary.RegisterAsWorkerCommand.ProfileCanExecute(System.Int64)">
            <summary>
            Revisa si no es un user del sistema debe poder usarlo
            </summary>
            <param name="userID">Identificador de Telegram del usuario que ejecuto el comando</param>
            <returns>True si puede, false si no esta habilitado</returns>
        </member>
        <member name="M:ClassLibrary.RegisterAsWorkerCommand.Execute(System.Int64,System.String)">
            <summary>
            Operación polimorifica que en este caso se encarga de ir tomando los datos necesarios 
            para registrar/crear un user como worker. Si los datos están mal lo obliga a ingresarlos bien
            o a cancelar el comando.
            </summary>
            <param name="userID"> Identificador del usuario que ejecuta el comando</param>
            <param name="inputData"> Los datos que tiene que llegarle al comando</param>
            <returns> Mensaje de que paso en cada paso de la ejecución del comando</returns>
        </member>
        <member name="T:ClassLibrary.RegisterAsWorkerCommand.RegisterAsWorkerState">
            <summary>
            Determina los estados que tiene el comando.
            </summary>
        </member>
        <member name="F:ClassLibrary.RegisterAsWorkerCommand.RegisterAsWorkerState.NoStarted">
            Para cuando no se ha iniciado el comando o se detuvo. 
            Si no se había iniciado y ahora InProccess pasa a estar en true, 
            se pide el nombre del usuario a registrarse. 
        </member>
        <member name="F:ClassLibrary.RegisterAsWorkerCommand.RegisterAsWorkerState.Started">
            Cuando inicia el comando y recoje el dato del nombre pedido en el paso anterior
        </member>
        <member name="F:ClassLibrary.RegisterAsWorkerCommand.RegisterAsWorkerState.LastNamePromt">
            Cuando el comando recoje el apellido
        </member>
        <member name="F:ClassLibrary.RegisterAsWorkerCommand.RegisterAsWorkerState.PhonePromt">
            Cuando el comando recoje el teléfono
        </member>
        <member name="F:ClassLibrary.RegisterAsWorkerCommand.RegisterAsWorkerState.AddressPromt">
            Cuando el comando recoje el nombre de la ubicación
        </member>
        <member name="T:ClassLibrary.RegisterAsWorkerCommand.WorkerData">
            <summary>
            Representa los datos que va obteniendo el comando RegisterAsWorkerCommand en los diferentes estados.
            </summary>
        </member>
        <member name="P:ClassLibrary.RegisterAsWorkerCommand.WorkerData.Name">
            <summary>
            El nombre que se ingresó en el estado RegisterAsWorkerState.Started.
            </summary>
        </member>
        <member name="P:ClassLibrary.RegisterAsWorkerCommand.WorkerData.LastName">
            <summary>
            El apellido que se ingresó en el estado RegisterAsWorkerState.LastNameProm.
            /// </summary>
        </member>
        <member name="P:ClassLibrary.RegisterAsWorkerCommand.WorkerData.Phone">
            <summary>
            El número que se ingresó en el estado RegisterAsWorkerState.PhonePromt.
            /// </summary>
        </member>
        <member name="P:ClassLibrary.RegisterAsWorkerCommand.WorkerData.Result">
            <summary>
            Resultado de la busqueda, en objetos de tipo
             IAddressREsult se guerda la información de la ubicación,
            así como si fue encontrada o no. 
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.RegisterAsWorkerCommand.WorkerData.Address">
            <summary>
            La ubicación que se ingresó en el estado RegisterAsWorkerState.FormatAddressLocation.
            /// </summary>
        </member>
        <member name="P:ClassLibrary.RegisterAsWorkerCommand.WorkerData.FormattedAddress">
            <summary>
            Dirección formateada que es uno de los datos que devuelve el buscador de direcciones
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.RegisterAsWorkerCommand.WorkerData.Latitude">
            <summary>
            La latitud que se ingresó en el estado RegisterAsWorkerState.LatitudeProm.
            </summary>
        </member>
        <member name="P:ClassLibrary.RegisterAsWorkerCommand.WorkerData.Longitude">
            <summary>
            La longitud que se ingresó en el estado RegisterAsWorkerState.LongitudePromt.
            </summary>
        </member>
        <member name="P:ClassLibrary.RegisterAsWorkerCommand.WorkerData.Response">
            <summary>
            Resuesta que se guarda en cada paso que se va haciendo, así si entra otro usuario a ejecutar el comando, no se pierde lo que se 
            le había dicho a ese en particular
            </summary>
            <value></value>
        </member>
        <member name="T:ClassLibrary.ResponseAEmployerCommand">
            <summary>
            Comando encargado responder a la solicitud de contacto del employer
            haciendo referencia a que quiere contratarlo para un servicio en particular
            
            Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            /// Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            </summary>
        </member>
        <member name="P:ClassLibrary.ResponseAEmployerCommand.Name">
            <summary>
            Es el nombre que tendrá el comando y que lo diferenciará de otros comandos
            </summary>
            <value>El nombre que se le especifique</value>
        </member>
        <member name="P:ClassLibrary.ResponseAEmployerCommand.InProccess">
            <summary>
            Propiedad de solo lectura, compartida por el tipo ICommand, para que se sepa 
            si el comando se esta ejecutando (en cualquiera de sus pasos),  o si ya termino y 
            se puede pasar a otro.
            </summary>
            <value>true si todavía se esta ejecutando, false si ya termino o no ha empezado</value>/
        </member>
        <member name="M:ClassLibrary.ResponseAEmployerCommand.#ctor">
            <summary>
            Se encarga de asignarle un valor a la propiedad del nombre con el fin
            de diferenciar entre un comando y otro
            </summary>
        </member>
        <member name="P:ClassLibrary.ResponseAEmployerCommand.State">
            <summary>
            Propiedad que guía al propio comando en que paso debe estar ahora, y a sabiendas de eso, hace algo.
            El valor por defecto es que no inicio el comando, NoStarted
            </summary>
            <value></value>
        </member>
        <member name="F:ClassLibrary.ResponseAEmployerCommand.stateForUser">
            <summary>
            Diccionario que guarda el userID de cada usuario que ha ejecutado el comando y le guarda el estado en el que 
            quedó por última vez, así no se pisa entre la entrada de uno y la otra.
            </summary>
            <returns></returns>
        </member>
        <member name="F:ClassLibrary.ResponseAEmployerCommand.data">
            <summary>
            Los datos  para un usuario que va obteniendo el comando en los diferentes estados.
            </summary>
        </member>
        <member name="M:ClassLibrary.ResponseAEmployerCommand.RestoreData(System.Int64)">
            <summary>
            Se encarga de resturar los datos que genero el comando cuando entro el user la vez pasada o en otra oportunidad
            Si es la primera vez que entra, lo pone en el diccionario
            </summary>
        </member>
        <member name="M:ClassLibrary.ResponseAEmployerCommand.Cancel(System.Int64)">
            <summary>
            Cancela la ejecución del comando
            </summary>
            <returns>Mensaje con el nombre del comando a modo de confirmación de que se 
            cancelo el comando</returns>
        </member>
        <member name="M:ClassLibrary.ResponseAEmployerCommand.ProfileCanExecute(System.Int64)">
            <summary>
            Revisa si es un worker, si es worker y no otro puede ejecutar este comando
            </summary>
            <param name="userID">Identificador de Telegram del usuario que ejecuto el comando</param>
            <returns>True si puede, false si no esta habilitado</returns>
        </member>
        <member name="M:ClassLibrary.ResponseAEmployerCommand.Execute(System.Int64,System.String)">
            <summary>
            Este método permite que el worker envie un "respuesta", a la solicitud, pasando los datos de contacto en caso 
            de aceptar, enviando un negativo en caso de no aceptar. 
            </summary>
            <param name="userID"> identificador del usuario que ejecuta el comando</param>
            <param name="inputData"> Los datos que tiene que llegarle al mensaje</param>
            <returns> Mensaje de que paso en cada paso de la ejecución del comando</returns>
        </member>
        <member name="T:ClassLibrary.ResponseAEmployerCommand.ReponseEmployerState">
            <summary>
            Estados que puede tener el comando
            </summary>
        </member>
        <member name="F:ClassLibrary.ResponseAEmployerCommand.ReponseEmployerState.NoStarted">
            Para cuando no se ha iniciado el comando o se detuvo. 
            Si no se había iniciado y ahora InProccess pasa a estar en true, 
            se pide el identificador de la notificación de contacto, para responder 
            esa notificación
        </member>
        <member name="F:ClassLibrary.ResponseAEmployerCommand.ReponseEmployerState.Started">
            Cuando inicia el comando pide el ID de la oferta de trabajo
        </member>
        <member name="F:ClassLibrary.ResponseAEmployerCommand.ReponseEmployerState.ConfirmOrCancelContactPromt">
            Paso en el que se pide su decisión, si es no o si
        </member>
        <member name="T:ClassLibrary.ResponseAEmployerCommand.ReponseEmployerData">
            <summary>
            Representa los datos que va obteniendo el comando en los diferentes estados.
            </summary>
        </member>
        <member name="P:ClassLibrary.ResponseAEmployerCommand.ReponseEmployerData.EmployerResponded">
            <summary>
            El objeto employer al que se le quiere enviar la notificación
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.ResponseAEmployerCommand.ReponseEmployerData.NotificationToReply">
            <summary>
             Objeto que representa a la notifiación que va a responder el user
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.ResponseAEmployerCommand.ReponseEmployerData.Response">
            <summary>
            La respuesta a devolver al usuario.
            </summary>
            <value></value>
        </member>
        <member name="T:ClassLibrary.SearchAllWorkOfferCommand">
            <summary>
            Comando encargado de buscar y devolver todas las ofertas de trabajo que se han hechos
            
            Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            /// Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            </summary>
        </member>
        <member name="P:ClassLibrary.SearchAllWorkOfferCommand.Name">
            <summary>
            Es el nombre que tendrá el comando y que lo diferenciará de otros comandos
            </summary>
            <value>El nombre que se le especifique</value>
        </member>
        <member name="P:ClassLibrary.SearchAllWorkOfferCommand.InProccess">
            <summary>
            Propiedad de solo lectura, compartida por el tipo ICommand, para que se sepa 
            si el comando se esta ejecutando (en cualquiera de sus pasos),  o si ya termino y 
            se puede pasar a otro.
            </summary>
            <value>true si todavía se esta ejecutando, false si ya termino o no ha empezado</value>/
        </member>
        <member name="M:ClassLibrary.SearchAllWorkOfferCommand.#ctor">
            <summary>
            Se encarga de asignarle un valor a la propiedad del nombre con el fin
            de diferenciar entre un comando y otro
            </summary>
        </member>
        <member name="M:ClassLibrary.SearchAllWorkOfferCommand.Cancel(System.Int64)">
            <summary>
            Cancela la ejecución del comando
            </summary>
            <returns>Mensaje con el nombre del comando a modo de confirmación de que se 
            cancelo el comando</returns>
        </member>
        <member name="M:ClassLibrary.SearchAllWorkOfferCommand.ProfileCanExecute(System.Int64)">
            <summary>
            Prueba de que si no es admin o worker o employer, no puede usarlo
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClassLibrary.SearchAllWorkOfferCommand.RestoreData(System.Int64)">
            <summary>
            Se encarga de resturar los datos que genero el comando cuando entro el user la vez pasada o en otra oportunidad
            Si es la primera vez que entra, lo pone en el diccionario
            </summary>
            <param dataOfWorker.Name="userID"></param>
        </member>
        <member name="M:ClassLibrary.SearchAllWorkOfferCommand.Execute(System.Int64,System.String)">
            <summary>
            Método que se encarga de ejecutar el comportamiento de este comando. En este caso
            se encarga de devolver todas las ofertas de trabajo que hay en el sistema y que estan Published
            </summary>
            <param name="userID"> Identificador del usuario que ejecuta el comando</param>
            <param name="inputData"> Los datos que tiene que llegarle al comando</param>
            <returns>Mensaje de respuesta en base a lo que esta pasando en el paso actual</returns>
        </member>
        <member name="T:ClassLibrary.SearchFilteredWorkOfferCommand">
            <summary>
            Comando encargado de buscar y devolver todas las ofertas de trabajo que se han hechos filtradas por la cateogoría indicada
            
            Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            /// Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            </summary>
        </member>
        <member name="P:ClassLibrary.SearchFilteredWorkOfferCommand.Name">
            <summary>
            Es el nombre que tendrá el comando y que lo diferenciará de otros comandos
            </summary>
            <value>El nombre que se le especifique</value>
        </member>
        <member name="P:ClassLibrary.SearchFilteredWorkOfferCommand.InProccess">
            <summary>
            Propiedad de solo lectura, compartida por el tipo ICommand, para que se sepa 
            si el comando se esta ejecutando (en cualquiera de sus pasos),  o si ya termino y 
            se puede pasar a otro.
            </summary>
            <value>true si todavía se esta ejecutando, false si ya termino o no ha empezado</value>/
        </member>
        <member name="M:ClassLibrary.SearchFilteredWorkOfferCommand.#ctor">
            <summary>
            Se encarga de asignarle un valor a la propiedad del nombre con el fin
            de diferenciar entre un comando y otro
            </summary>
        </member>
        <member name="P:ClassLibrary.SearchFilteredWorkOfferCommand.State">
            <summary>
            Propiedad que guía al propio comando en que paso debe estar ahora, y a sabiendas de eso, hace algo.
            El valor por defecto es que no inicio el comando, NoStarted
            </summary>
            <value></value>
        </member>
        <member name="F:ClassLibrary.SearchFilteredWorkOfferCommand.stateForUser">
            <summary>
            Diccionario que guarda el userID de cada usuario que ha ejecutado el comando y le guarda el estado en el que 
            quedo por última vez, así no se pisa entre la entrada de uno y la otra.
            </summary>
            <returns></returns>
        </member>
        <member name="F:ClassLibrary.SearchFilteredWorkOfferCommand.data">
            <summary>
            Los datos  para un usuario que va obteniendo el comando en los diferentes estados.
            </summary>
        </member>
        <member name="M:ClassLibrary.SearchFilteredWorkOfferCommand.Cancel(System.Int64)">
            <summary>
            Cancela la ejecución del comando
            </summary>
            <returns>Mensaje con el nombre del comando a modo de confirmación de que se 
            cancelo el comando</returns>
        </member>
        <member name="M:ClassLibrary.SearchFilteredWorkOfferCommand.RestoreData(System.Int64)">
            <summary>
            Se encarga de resturar los datos que genero el comando cuando entro el user la vez pasada o en otra oportunidad
            Si es la primera vez que entra, lo pone en el diccionario
            </summary>
            <param dataOfWorker.Name="userID"></param>
        </member>
        <member name="M:ClassLibrary.SearchFilteredWorkOfferCommand.ProfileCanExecute(System.Int64)">
            <summary>
            Revisa si es un employer, si es employer y no otro puede ejecutar este comando
            </summary>
            <param name="userID">Identificador de Telegram del usuario que ejecuto el comando</param>
            <returns>True si puede, false si no esta habilitado</returns>
        </member>
        <member name="M:ClassLibrary.SearchFilteredWorkOfferCommand.Execute(System.Int64,System.String)">
            <summary>
            Operación polimorfica que se encarga de devolver todas las ofertas de trabajo siendo filtradas por cierto criterio
            que se le solicita al usuario. 
            </summary>
            <param name="userID"> Identificador del usuario que ejecuta el comando</param>
            <param name="inputData"> Los datos que tiene que llegarle al comando</param>
            <returns>Mensaje de respuesta en base a lo que esta pasando en el paso actual</returns>
        </member>
        <member name="T:ClassLibrary.SearchFilteredWorkOfferCommand.SearchFilteredState">
            <summary>
            Diferentes estados por los que puede pasar este comando
            </summary>
        </member>
        <member name="F:ClassLibrary.SearchFilteredWorkOfferCommand.SearchFilteredState.NoStarted">
            Para cuando no se ha iniciado el comando o se detuvo. 
            Si no se había iniciado y ahora InProccess pasa a estar en true, 
            se pide el criterio con el cual filtrar las ofertas
        </member>
        <member name="F:ClassLibrary.SearchFilteredWorkOfferCommand.SearchFilteredState.Started">
            Inicio el comando, por lo que pide el criterio para filtrar
        </member>
        <member name="F:ClassLibrary.SearchFilteredWorkOfferCommand.SearchFilteredState.CriterionPromt">
            Criterio que se le pasa al filtro
        </member>
        <member name="T:ClassLibrary.SearchFilteredWorkOfferCommand.SearchFilteredData">
            <summary>
            Representa los datos que va obteniendo el comando SearchFilteredWorkOfferCommand en los diferentes estados.
            </summary>
        </member>
        <member name="P:ClassLibrary.SearchFilteredWorkOfferCommand.SearchFilteredData.FilterAplicated">
            <summary>
            Guardo el filtro que va a user en base a lo que ingresó en el estado SearchFilteredState.Started.
            </summary>
        </member>
        <member name="P:ClassLibrary.SearchFilteredWorkOfferCommand.SearchFilteredData.Response">
            <summary>
            Resuesta que se guarda en cada paso que se va haciendo, así si entra otro usuario a ejecutar el comando, no se pierde lo que se 
            le había dicho a ese en particular
            </summary>
            <value></value>
        </member>
        <member name="T:ClassLibrary.SearchSortedStateWorkOfferCommand">
             <summary>
             Comando encargado de buscar y devolver todas las ofertas de trabajo que se han hechos filtradas por la cateogoría indicada
            
             Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
             al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
             Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
             decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
             sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
             
             Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
             ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
             no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
             /// Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
             al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
             Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
             decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
             sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
             
             Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
             ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
             no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
             </summary>
        </member>
        <member name="P:ClassLibrary.SearchSortedStateWorkOfferCommand.Name">
            <summary>
            Es el nombre que tendrá el comando y que lo diferenciará de otros comandos
            </summary>
            <value>El nombre que se le especifique</value>
        </member>
        <member name="P:ClassLibrary.SearchSortedStateWorkOfferCommand.State">
            <summary>
            Propiedad que guía al propio comando en que paso debe estar ahora, y a sabiendas de eso, hace algo.
            El valor por defecto es que no inicio el comando, NoStarted
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.SearchSortedStateWorkOfferCommand.InProccess">
            <summary>
            Propiedad de solo lectura, compartida por el tipo ICommand, para que se sepa 
            si el comando se esta ejecutando (en cualquiera de sus pasos),  o si ya termino y 
            se puede pasar a otro.
            </summary>
            <value>true si todavía se esta ejecutando, false si ya termino o no ha empezado</value>/
        </member>
        <member name="M:ClassLibrary.SearchSortedStateWorkOfferCommand.#ctor">
            <summary>
            Se encarga de asignarle un valor a la propiedad del nombre con el fin
            de diferenciar entre un comando y otro. También inicializa lo necesario 
            para hacer uso de la APILocation
            </summary>
        </member>
        <member name="F:ClassLibrary.SearchSortedStateWorkOfferCommand.stateForUser">
            <summary>
            Diccionario que guarda el userID de cada usuario que ha ejecutado el comando y le guarda el estado en el que 
            quedo por última vez, así no se pisa entre la entrada de uno y la otra.
            </summary>
            <returns></returns>
        </member>
        <member name="F:ClassLibrary.SearchSortedStateWorkOfferCommand.data">
            <summary>
            Los datos  para un usuario que va obteniendo el comando en los diferentes estados.
            </summary>
        </member>
        <member name="M:ClassLibrary.SearchSortedStateWorkOfferCommand.Cancel(System.Int64)">
            <summary>
            Cancela la ejecución del comando
            </summary>
            <returns>Mensaje con el nombre del comando a modo de confirmación de que se 
            cancelo el comando</returns>
        </member>
        <member name="M:ClassLibrary.SearchSortedStateWorkOfferCommand.RestoreData(System.Int64)">
            <summary>
            Se encarga de resturar los datos que genero el comando cuando entro el user la vez pasada o en otra oportunidad
            Si es la primera vez que entra, lo pone en el diccionario
            </summary>
            <param name="userID">ID del usuario de Telegram</param>
        </member>
        <member name="M:ClassLibrary.SearchSortedStateWorkOfferCommand.ProfileCanExecute(System.Int64)">
            <summary>
            Revisa si es un employer, si es employer y no otro puede ejecutar este comando
            </summary>
            <param name="userID">Identificador de Telegram del usuario que ejecuto el comando</param>
            <returns>True si puede, false si no esta habilitado</returns>
        </member>
        <member name="F:ClassLibrary.SearchSortedStateWorkOfferCommand.sorters">
            <summary>
            Ordenadores que se pueden usar para ordenar el resultado querido
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClassLibrary.SearchSortedStateWorkOfferCommand.Execute(System.Int64,System.String)">
            <summary>
            Los que hace es buscar entre la lista de ordenadores, para ver si el nombre de 
            alguno concide con lo puesto en la entrada. Si concide lo usa y retorna el resultado 
            de la ordenación, siendo esto un texto con las ofertas ordenadas o un mensaje de alerta 
            si no se pudo realizar la tarea. 
            </summary>
            <param name="userID"></param>
            <param name="inputData"></param>
            <returns>Mensaje de respuesta en base a lo que esta pasando en el paso actual</returns>
        </member>
        <member name="T:ClassLibrary.SearchSortedStateWorkOfferCommand.SearchSortedState">
            <summary>
            Indica los diferentes estados que puede tener el comando SerachSortedWorkOfferCommand.
            </summary>
        </member>
        <member name="F:ClassLibrary.SearchSortedStateWorkOfferCommand.SearchSortedState.NoStarted">
            Para cuando no se ha iniciado el comando o se detuvo. 
            Si no se había iniciado y ahora InProccess pasa a estar en true, 
            se pide el criterio con el cual ordenar las ofertas
        </member>
        <member name="F:ClassLibrary.SearchSortedStateWorkOfferCommand.SearchSortedState.Started">
            Inicio el comando, por lo que recoje el criterio
        </member>
        <member name="T:ClassLibrary.SearchSortedStateWorkOfferCommand.SerachSortedData">
            <summary>
            Representa los datos que va obteniendo el comando SearchSortedWorkOfferCommand en los diferentes estados.
            </summary>
        </member>
        <member name="P:ClassLibrary.SearchSortedStateWorkOfferCommand.SerachSortedData.Option">
            <summary>
            La descripción que se ingresó en el estado SerachSortedState.Started.
            </summary>
        </member>
        <member name="P:ClassLibrary.SearchSortedStateWorkOfferCommand.SerachSortedData.Response">
            <summary>
            Resuesta que se guarda en cada paso que se va haciendo, así si entra otro usuario a ejecutar el comando, no se pierde lo que se 
            le había dicho a ese en particular
            </summary>
            <value></value>
        </member>
        <member name="T:ClassLibrary.ShowCategoriesCommand">
            <summary>
            Comando encargado de hacer el contacto entre un empleador y un empleado,
            haciendo referencia a que quiere contratarlo para un servicio en particular
            
            Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            /// Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            </summary>
        </member>
        <member name="P:ClassLibrary.ShowCategoriesCommand.Name">
            <summary>
            Nombre del comando
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.ShowCategoriesCommand.InProccess">
            <summary>
            Propiedad de solo lectura, compartida por el tipo ICommand, para que se sepa 
            si el comando se esta ejecutando (en cualquiera de sus pasos),  o si ya termino y 
            se puede pasar a otro.
            </summary>
            <value>true si todavía se esta ejecutando, false si ya termino o no ha empezado</value>/
        </member>
        <member name="M:ClassLibrary.ShowCategoriesCommand.#ctor">
            <summary>
            Se encarga de asignarle un valor a la propiedad del nombre con el fin
            de diferenciar entre un comando y otro.
            </summary>
        </member>
        <member name="M:ClassLibrary.ShowCategoriesCommand.Cancel(System.Int64)">
            <summary>
            Cancela la ejecución del comando
            </summary>
            <returns>Mensaje con el nombre del comando a modo de confirmación de que se 
            cancelo el comando</returns>
        </member>
        <member name="M:ClassLibrary.ShowCategoriesCommand.RestoreData(System.Int64)">
            <summary>
            Se encarga de resturar los datos que genero el comando cuando entro el user la vez pasada o en otra oportunidad
            Si es la primera vez que entra, lo pone en el diccionario
            </summary>
            <param dataOfWorker.Name="userID"></param>
        </member>
        <member name="M:ClassLibrary.ShowCategoriesCommand.ProfileCanExecute(System.Int64)">
            <summary>
            Prueba de que si no es admin o worker o employer, no puede usarlo
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClassLibrary.ShowCategoriesCommand.Execute(System.Int64,System.String)">
            <summary>
            Devuelve la lista de categorías existentes en el sistema.
            </summary>
            <param name="userID"> Identificador del usuario que ejecuta el comando</param>
            <param name="inputData"> Los datos que tiene que llegarle al comando</param>
            <returns> Mensaje de que paso en cada paso de la ejecución del comando</returns>
        </member>
        <member name="T:ClassLibrary.ShowNotificationsCommand">
            <summary>
            Comando encargado de mostrar las notificaciones de un worker o un employer, dependidendo de cual de los dos esta buscando ver sus 
            notificacioens. 
            
            Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            /// Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            </summary>
        </member>
        <member name="P:ClassLibrary.ShowNotificationsCommand.Name">
            <summary>
            Nombre del comando en particular
            </summary>
            <value>String que se le especifique</value>
        </member>
        <member name="P:ClassLibrary.ShowNotificationsCommand.InProccess">
            <summary>
            Propiedad de solo lectura, compartida por el tipo ICommand, para que se sepa 
            si el comando se esta ejecutando (en cualquiera de sus pasos),  o si ya termino y 
            se puede pasar a otro.
            </summary>
            <value>true si todavía se esta ejecutando, false si ya termino o no ha empezado</value>/
        </member>
        <member name="M:ClassLibrary.ShowNotificationsCommand.#ctor">
            <summary>
            Se encarga de cargarle el nombre a la propiedad Name
            </summary>
        </member>
        <member name="M:ClassLibrary.ShowNotificationsCommand.Cancel(System.Int64)">
            <summary>
            Cancela la ejecución del comando
            </summary>
            <returns>Mensaje con el nombre del comando a modo de confirmación de que se 
            cancelo el comando</returns>
        </member>
        <member name="M:ClassLibrary.ShowNotificationsCommand.RestoreData(System.Int64)">
            <summary>
            Se encarga de resturar los datos que genero el comando cuando entro el user la vez pasada o en otra oportunidad
            Si es la primera vez que entra, lo pone en el diccionario
            </summary>
            <param dataOfWorker.Name="userID"></param>
        </member>
        <member name="M:ClassLibrary.ShowNotificationsCommand.ProfileCanExecute(System.Int64)">
            <summary>
            Controla de que si no es un user: worker o employer, no puede usarlo
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClassLibrary.ShowNotificationsCommand.Execute(System.Int64,System.String)">
            <summary>
            Esta versión o implementación de Execute lo que hace es devolver la lista de notificaciones 
            que tiene el user que esta escribiendo. Si no es un worker o un employer, no le va a dejar ejecutarlo.
            Si no tiene notificaciones le dirá que no las tiene en vez de no mostrar nada. 
            </summary>
            <param name="userID"> Identificador del usuario que ejecuta el comando</param>
            <param name="inputData"> Los datos que tiene que llegarle al comando</param>
            <returns> Devuelve la lista de notificaciones que tiene o un mensaje indicando por que no puede hacerlo</returns>
        </member>
        <member name="T:ClassLibrary.ShowRateEmployerCommand">
            <summary>
            Comando encargado de mostrar la calificación de un empleador en espécifico. 
            
            Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            /// Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            </summary>
        </member>
        <member name="P:ClassLibrary.ShowRateEmployerCommand.Name">
            <summary>
            Es el nombre que tendrá el comando y que lo diferenciará de otros comandos
            </summary>
            <value>El nombre que se le especifique</value>
        </member>
        <member name="P:ClassLibrary.ShowRateEmployerCommand.InProccess">
            <summary>
            Propiedad de solo lectura, compartida por el tipo ICommand, para que se sepa 
            si el comando se esta ejecutando (en cualquiera de sus pasos),  o si ya termino y 
            se puede pasar a otro.
            </summary>
            <value>true si todavía se esta ejecutando, false si ya termino o no ha empezado</value>/
        </member>
        <member name="P:ClassLibrary.ShowRateEmployerCommand.State">
            <summary>
            Propiedad que guía al propio comando en que paso debe estar ahora, y a sabiendas de eso, hace algo.
            El valor por defecto es que no inicio el comando, NoStarted
            </summary>
            <value></value>
        </member>
        <member name="F:ClassLibrary.ShowRateEmployerCommand.stateForUser">
            <summary>
            Diccionario que guarda el userID de cada usuario que ha ejecutado el comando y le guarda el estado en el que 
            quedo por última vez, así no se pisa entre la entrada de uno y la otra.
            </summary>
            <returns></returns>
        </member>
        <member name="F:ClassLibrary.ShowRateEmployerCommand.data">
            <summary>
            Los datos  para un usuario que va obteniendo el comando en los diferentes estados.
            </summary>
        </member>
        <member name="M:ClassLibrary.ShowRateEmployerCommand.#ctor">
            <summary>
            Establece el nombre que tendrá el comando
            </summary>
        </member>
        <member name="M:ClassLibrary.ShowRateEmployerCommand.Cancel(System.Int64)">
            <summary>
            Cancela la ejecución del comando
            </summary>
            <returns>Mensaje con el nombre del comando a modo de confirmación de que se 
            cancelo el comando</returns>
        </member>
        <member name="M:ClassLibrary.ShowRateEmployerCommand.RestoreData(System.Int64)">
            <summary>
            Se encarga de resturar los datos que genero el comando cuando entro el user la vez pasada o en otra oportunidad
            Si es la primera vez que entra, lo pone en el diccionario
            </summary>
            <param dataOfWorker.Name="userID"></param>
        </member>
        <member name="M:ClassLibrary.ShowRateEmployerCommand.ProfileCanExecute(System.Int64)">
            <summary>
            Controla de que si no es un admin o un worker, no pueda usarlo
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClassLibrary.ShowRateEmployerCommand.Execute(System.Int64,System.String)">
            <summary>
            Se encarga de resturar los datos que genero el comando cuando entro el user la vez pasada o en otra oportunidad
            Si es la primera vez que entra, lo pone en el diccionario
            </summary>
            <param name="userID"> Identificador del usuario que ejecuta el comando</param>
            <param name="inputData"> Los datos que tiene que llegarle al comando</param>
            <returns> Mensaje de que paso en cada paso de la ejecución del comando</returns>
        </member>
        <member name="T:ClassLibrary.ShowRateEmployerCommand.ShowRateEmployerState">
            <summary>
            Indica los diferentes estados que puede tener el comando.
            </summary>
        </member>
        <member name="F:ClassLibrary.ShowRateEmployerCommand.ShowRateEmployerState.NoStarted">
            Para cuando no se ha iniciado el comando o se detuvo. 
            Si no se había iniciado y ahora InProccess pasa a estar en true, 
            se pide el criterio con el id del employer del que quiere ver la calificación
        </member>
        <member name="F:ClassLibrary.ShowRateEmployerCommand.ShowRateEmployerState.Started">
            Inicio el comando, por lo que recoje el id el employer del que quiere verse la calificación
        </member>
        <member name="T:ClassLibrary.ShowRateEmployerCommand.ShowRateEmployerData">
            <summary>
            Representa los datos que va obteniendo el comando ShowRateEmployerCommand en los diferentes estados.
            </summary>
        </member>
        <member name="P:ClassLibrary.ShowRateEmployerCommand.ShowRateEmployerData.Response">
            <summary>
            Resuesta que se guarda en cada paso que se va haciendo, así si entra otro usuario a ejecutar el comando, no se pierde lo que se 
            le había dicho a ese en particular
            </summary>
            <value></value>
        </member>
        <member name="T:ClassLibrary.ShowRateWorkerCommand">
            <summary>
            Comando encargado de mostrar la calificación de un tarbajador en espécifico. 
            
            Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            /// Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            </summary>
        </member>
        <member name="P:ClassLibrary.ShowRateWorkerCommand.Name">
            <summary>
            Es el nombre que tendrá el comando y que lo diferenciará de otros comandos
            </summary>
            <value>El nombre que se le especifique</value>
        </member>
        <member name="P:ClassLibrary.ShowRateWorkerCommand.InProccess">
            <summary>
            Propiedad de solo lectura, compartida por el tipo ICommand, para que se sepa 
            si el comando se esta ejecutando (en cualquiera de sus pasos),  o si ya termino y 
            se puede pasar a otro.
            </summary>
            <value>true si todavía se esta ejecutando, false si ya termino o no ha empezado</value>/
        </member>
        <member name="P:ClassLibrary.ShowRateWorkerCommand.State">
            <summary>
            Propiedad que guía al propio comando en que paso debe estar ahora, y a sabiendas de eso, hace algo.
            El valor por defecto es que no inicio el comando, NoStarted
            </summary>
            <value></value>
        </member>
        <member name="F:ClassLibrary.ShowRateWorkerCommand.stateForUser">
            <summary>
            Diccionario que guarda el userID de cada usuario que ha ejecutado el comando y le guarda el estado en el que 
            quedo por última vez, así no se pisa entre la entrada de uno y la otra.
            </summary>
            <returns></returns>
        </member>
        <member name="F:ClassLibrary.ShowRateWorkerCommand.data">
            <summary>
            Los datos  para un usuario que va obteniendo el comando en los diferentes estados.
            </summary>
        </member>
        <member name="M:ClassLibrary.ShowRateWorkerCommand.#ctor">
            <summary>
            Establece el nombre que tendrá el comando
            </summary>
        </member>
        <member name="M:ClassLibrary.ShowRateWorkerCommand.Cancel(System.Int64)">
            <summary>
            Cancela la ejecución del comando
            </summary>
            <returns>Mensaje con el nombre del comando a modo de confirmación de que se 
            cancelo el comando</returns>
        </member>
        <member name="M:ClassLibrary.ShowRateWorkerCommand.RestoreData(System.Int64)">
            <summary>
            Se encarga de resturar los datos que genero el comando cuando entro el user la vez pasada o en otra oportunidad
            Si es la primera vez que entra, lo pone en el diccionario
            </summary>
            <param dataOfWorker.Name="userID"></param>
        </member>
        <member name="M:ClassLibrary.ShowRateWorkerCommand.ProfileCanExecute(System.Int64)">
            <summary>
            Controla de que si no es un admin o un employer, no pueda usarlo
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClassLibrary.ShowRateWorkerCommand.Execute(System.Int64,System.String)">
            <summary>
            Se encarga de resturar los datos que genero el comando cuando entro el user la vez pasada o en otra oportunidad
            Si es la primera vez que entra, lo pone en el diccionario
            </summary>
             /// <param name="userID"> Identificador del usuario que ejecuta el comando</param>
            <param name="inputData"> Los datos que tiene que llegarle al comando</param>
            <returns> Mensaje de que paso en cada paso de la ejecución del comando</returns>
        </member>
        <member name="T:ClassLibrary.ShowRateWorkerCommand.ShowRateWorkerState">
            <summary>
            Indica los diferentes estados que puede tener el comando.
            </summary>
        </member>
        <member name="F:ClassLibrary.ShowRateWorkerCommand.ShowRateWorkerState.NoStarted">
            Para cuando no se ha iniciado el comando o se detuvo. 
            Si no se había iniciado y ahora InProccess pasa a estar en true, 
            se pide el criterio con el id del employer del que quiere ver la calificación
        </member>
        <member name="F:ClassLibrary.ShowRateWorkerCommand.ShowRateWorkerState.Started">
            Inicio el comando, por lo que recoje el id el worker del que quiere verse la calificación
        </member>
        <member name="T:ClassLibrary.ShowRateWorkerCommand.ShowRateWorkerData">
            <summary>
            Representa los datos que va obteniendo el comando ShowRateWorkerCommand en los diferentes estados.
            </summary>
        </member>
        <member name="P:ClassLibrary.ShowRateWorkerCommand.ShowRateWorkerData.Response">
            <summary>
            Resuesta que se guarda en cada paso que se va haciendo, así si entra otro usuario a ejecutar el comando, no se pierde lo que se 
            le había dicho a ese en particular
            </summary>
            <value></value>
        </member>
        <member name="T:ClassLibrary.StartCommand">
            <summary>
            Comando que se ejecuta cuando el usuario inserta /start.
            
            Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            /// Sigue el principio de inversión de dependencias puesto que depende de una abstracción (ICommand), 
            al igual que la clase concreta que termina haciendo uso de esta, por ende evitamos dependencias indeseables. 
            Al aplicar DIP, podemos cambiar en tiempo de ejecución el comando a usar (como sucede realmente), por lo cual podemos
            decir que se cumple con LSP. Esto a su vez nos lleva a decir que como se esta implementando una intarfaz, implementando 
            sus operaciones pero al modo que necesite cada comando, estas operaciones terminan siendo polimorficas. 
            
            Por último, esta clase cumple con OCP, el principio de abierto y cerrado, por que se define un tipo abstracto, la interfaz
            ICommand, con sus operaciones y propiedades, pero en la práctica esta clase incorpora otras responsabilidad que originalmente
            no estan definidas en el contrato del tipo (abierto a la extensión), pero sin modificar lo que ya estaba hecho (cerrado a la modificación).
            </summary>
        </member>
        <member name="P:ClassLibrary.StartCommand.Name">
            <summary>
            String que debe coincidir con la entrada del usuario.
            </summary>
            <value></value>
        </member>
        <member name="M:ClassLibrary.StartCommand.#ctor">
            <summary>
            Construye con el string necesario para asociarse con el InputInterfacer.
            </summary>
        </member>
        <member name="M:ClassLibrary.StartCommand.ProfileCanExecute(System.Int64)">
            <summary>
            Cualquier usuario de Telegram puede usar este comando
            </summary>
            <returns></returns>
        </member>
        <member name="P:ClassLibrary.StartCommand.InProccess">
            <summary>
            Cancela la ejecución del comando
            </summary>
            <value></value>
        </member>
        <member name="M:ClassLibrary.StartCommand.Cancel(System.Int64)">
            <summary>
            Método cancel necesario por la interfaz. Este comando al ser de un solo paso, no necesita usar cancel.
            </summary>
            <param name="userID"></param>
            <returns>Mensaje con el nombre del comando a modo de confirmación de que se 
            cancelo el comando</returns>
        </member>
        <member name="M:ClassLibrary.StartCommand.RestoreData(System.Int64)">
            <summary>
            Se encarga de resturar los datos que genero el comando cuando entro el user la vez pasada o en otra oportunidad
            Si es la primera vez que entra, lo pone en el diccionario
            </summary>
            <param dataOfWorker.Name="userID"></param>
        </member>
        <member name="M:ClassLibrary.StartCommand.Execute(System.Int64,System.String)">
            <summary>
            Devuelve la lista de comandos existentes.
            </summary>
            <param name="userID"> Identificador del usuario que ejecuta el comando</param>
            <param name="inputData"> Los datos que tiene que llegarle al comando</param>
            <returns> Devuelve la lista de comandos disponibles que tienes dependiendo de si estas en el sitema o no y que rol tengas</returns>
        </member>
        <member name="T:ClassLibrary.Admin">
            <summary>
            Clase que modela al rol de Adminstrador en el bot.
            Se aplica herencia como técnica de reutilización de código en este caso, ya que 
            la propiedad de userID esta en la clase padre.
            </summary>
        </member>
        <member name="M:ClassLibrary.Admin.#ctor(System.Int64)">
            <summary>
            Se crea al Admin con el ID como dato único que posee
            </summary>
            <param name="userID"> ID de la plataforma que usa nuestro bot</param>
            <returns>Devulve una instancia de la clase Admin</returns>
        </member>
        <member name="T:ClassLibrary.Database">
            <summary>
            Clase que se encargará de contener los datos del programa, siendo estos las ofertas de servicios,
            las categorías, los trabajadores, los administradores y los empleadores. 
            Para diseñarla se uso el principio Expert, ya que consideramos que la clase que alojara objetos era la más adecuada para 
            devolver la información sobre los objetos, así como para crearlos, quitarlos de la lista, decir si existe uno en base a su identificador,
            o devolver un objeto en particular al especificarse una información.
            
            Por otro lado, esta clase es un Singleton para así poder tener una única instancia de los datos mientras se ejecuta el programa, 
            de lo contrario podría darse que existierán dos instancias con datos diferentes al mismo tiempo. 
            </summary>
        </member>
        <member name="F:ClassLibrary.Database.instance">
            <summary>
            Variable privada que contiene la instancia del objeto, siguiendo con la forma de hacer un Singleton
            </summary>
        </member>
        <member name="P:ClassLibrary.Database.UltimateIDWorkOffer">
            <summary>
             Para saber cual es la última id de work offer. Cuando se agrega una oferta se incrementa en uno, y ese termina siendo el identify de esa oferta
            </summary>
        </member>
        <member name="P:ClassLibrary.Database.Instance">
            <summary>
            Property que se encarga de devolver la instancia de Database si existe, 
            si no existe la crea y la devuelve. De esta manera siempre se accede a la misma instancia 
            </summary>
        </member>
        <member name="F:ClassLibrary.Database.categories">
            <summary>
            Decidimos que las categorias serían un nombre, por ende tenemos una lista de strings
            donde serán agregados y consultados los nombres de la categorias durante el programa.
            
            No se usa un IList porque luego el método GetAllCategories devuelve una lista de solo
            lectura, usando el método AsReadOnly que tiene el tipo List. Esto se hace para mantener
            la encapsualción y la estabilidad de los datos, evitando que se cambien datos de los objetos
            (listas), que se pasan.
            </summary>
            <returns></returns>
        </member>
        <member name="F:ClassLibrary.Database.workOffers">
            <summary>
            Lista que contendrá las ofertas de trabajo que se van creando en el sistema.
            No se usa un IList porque luego el método GetAllWorkOffers devuelve una lista de solo
            lectura, usando el método AsReadOnly que tiene el tipo List. Esto se hace para mantener
            la encapsualción y la estabilidad de los datos, evitando que se cambien datos de los objetos
            (listas), que se pasan.
            </summary>
            <returns></returns>
        </member>
        <member name="F:ClassLibrary.Database.workers">
            <summary>
            Lista que contiene a todos los trabajadores que estaran en al aplicación.
            No se usa un IList porque luego el método GetWorkers devuelve una lista de solo
            lectura, usando el método AsReadOnly que tiene el tipo List. Esto se hace para mantener
            la encapsualción y la estabilidad de los datos, evitando que se cambien datos de los objetos
            (listas), que se pasan.
            </summary>
            <returns></returns>
        </member>
        <member name="F:ClassLibrary.Database.employers">
            <summary>
            Lista que contiene a todos los empleadores que estaran en al aplicación.
            No se usa un IList porque luego el método GetEmployers devuelve una lista de solo
            lectura, usando el método AsReadOnly que tiene el tipo List. Esto se hace para mantener
            la encapsualción y la estabilidad de los datos, evitando que se cambien datos de los objetos
            (listas), que se pasan.
            </summary>
            <returns></returns>
        </member>
        <member name="F:ClassLibrary.Database.admins">
            <summary>
            Lista que contiene a todos los administradores que estaran en al aplicación.
            No se usa un IList porque luego el método GetAdmins devuelve una lista de solo
            lectura, usando el método AsReadOnly que tiene el tipo List. Esto se hace para mantener
            la encapsualción y la estabilidad de los datos, evitando que se cambien datos de los objetos
            (listas), que se pasan.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClassLibrary.Database.#ctor">
            <summary>
            Constructor privado para implementar el patrón Singleton
            </summary>
        </member>
        <member name="M:ClassLibrary.Database.AddWorkOffer(System.String,System.String,System.Int32,System.Int64,System.Collections.Generic.IList{System.String},System.Int32)">
            <summary>
            Método que se encarga de crear una oferta de trabajo aplicando el patrón Creator, ya que que se le pasa
            todos los datos necesarios para construir el objeto. A su vez, se puede aplicar creator por que la clase Database
            contiene objetos de este tipo en una lista. 
            </summary>
            <param name="description"> Descripción de la oferta; los datos que quiera ingrear el worker para presentar su trabajo</param>
            <param name="currency"> Moneda que tendrá la oferta de trabajo</param>
            <param name="price"> Cuanto dinero vale el trabajo</param>
            <param name="ownerID"> Identificador del usuario que creo la oferta de trabajo</param>
            <param name="categoriesInput"> Lista de categorías en las que esta publicada la oferta</param>
            <param name="durationInDays"> Duración en días del trabajo en particular</param>
        </member>
        <member name="M:ClassLibrary.Database.GetAllWorkOffers">
            <summary>
            Devuleve los workOffers para que puedan usarla los comandos, pero siendo solo de lectura
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClassLibrary.Database.AddCategory(System.String)">
            <summary>
            Método encargado de crear nuevas categorías y agregarlas al contendor, en este caso una lista. En el caso de recibir 
            nombres en un formato no valido (minúsculas y con tildes), se cambia al formato correcto para esta información (mayúsculas y sin tildes). 
            </summary>
            <param name="categoryName"> nombre de la categoría o categoría en si, que se va a agregar</param>
        </member>
        <member name="M:ClassLibrary.Database.GetAllCategories">
            <summary>
            Devuleve las categorias para que puedan usarla los comandos, pero son de solo lectura
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClassLibrary.Database.DeleteWorkOffer(System.Int32)">
            <summary>
            Se encarga de dar de baja una oferta de trabajo
            Si existe alguna oferta con ese identificador procederá a "eliminarla"
            </summary>
            <param name="identify"> Identificador de la oferta de trabajo</param>
        </member>
        <member name="M:ClassLibrary.Database.AddWorker(System.Int64,System.String,System.String,System.String,System.String,System.Double,System.Double)">
            <summary>
            Se encarga de crear y agregar el trabajador a la lista de trabajadores. 
            En base al patrón Creator es que le pasamos los datos para crear el objeto, esto debido
            a que cumple con la condición de que la clase Database agrega objetos de tipo Worker.
            </summary>
            <param name="userID"> ID de la plataforma que le llega al user</param>
            <param name="name"> Nombre del trabajador</param>
            <param name="lastName"> Apellido del trabajador</param>
            <param name="phone"> Celular del trabajador</param>
            <param name="address"> Dirección del worker</param>
            <param name="latitude"> Latitud de la ubicación del worker</param>
            <param name="longitude"> Longitud de la ubicación del worker</param>
        </member>
        <member name="M:ClassLibrary.Database.AddEmployer(System.Int64,System.String,System.String,System.String,System.String,System.Double,System.Double)">
            <summary>
            Se encarga de crear y agregar el empleador a la lista de empledores. 
            En base a creator es que le pasamos los datos para crear el objeto, esto debido
            a que cumple con la condición de que la clase Database agrega objetos de tipo Employer
            </summary>
            <param name="userID"> ID de la plataforma que le llega al user</param>
            <param name="name"> Nombre del empleador</param>
            <param name="lastName"> Apellido del empleador</param>
            <param name="phone"> Celular del empleador</param>
            <param name="address"> Dirección del employer</param>
            <param name="latitude"> Latitud de la ubicación del employer</param>
            <param name="longitude"> Longitud de la ubicación del employer</param>
        </member>
        <member name="M:ClassLibrary.Database.AddAdmin(System.Int64)">
            <summary>
            Se encarga de crear y agregar el admin a la lista de administradores. 
            En base a Creator es que le pasamos los datos para crear el objeto, esto debido
            a que cumple con la condición de que la clase Database agrega objetos de tipo Admin
            </summary>
        </member>
        <member name="M:ClassLibrary.Database.GetWorkers">
            <summary>
            Se encarga de devolver los trabajadores de forma que pueda userse la información, pero 
            sin tocarla en la lista.
            </summary>
            <returns>Devulve la lista de trabajadores que contiene Database</returns>
        </member>
        <member name="M:ClassLibrary.Database.GetEmployers">
            <summary>
            Se encarga de devolver los empleadores de forma que pueda userse la información, pero 
            sin tocarla en la lista
            </summary>
            <returns>Devulve la lista de empleadores que contiene Database</returns>
        </member>
        <member name="M:ClassLibrary.Database.GetAdmins">
            <summary>
            Se encarga de devolver los administradores de forma que pueda userse la información, pero 
            sin tocarla en la lista.
            </summary>
            <returns>Devulve la lista de administradores que contiene Database pero como una lista de solo lectura</returns>
        </member>
        <member name="M:ClassLibrary.Database.ClearWorkers">
            <summary>
            Limpia la lista de los workers, pero solo se usa en los test
            </summary>
        </member>
        <member name="M:ClassLibrary.Database.ClearEmployers">
            <summary>
            Limpia la lista de los employers, pero solo se usa en los test
            </summary>
        </member>
        <member name="M:ClassLibrary.Database.ClearAdmins">
            <summary>
            Limpia la lista de los employers, pero solo se usa en los test
            </summary>
        </member>
        <member name="M:ClassLibrary.Database.ClearCategories">
            <summary>
            Limpia la lista de los categorías, pero solo se usa en los test
            </summary>
        </member>
        <member name="M:ClassLibrary.Database.ClearWorkOffers">
            <summary>
            Limpia la lista de los ofertas de trabajo, se usa en los test
            </summary>
        </member>
        <member name="M:ClassLibrary.Database.ExistAdmin(System.Int64)">
            <summary>
            Busca si hay algún admin que concida con ese identificador en el sistema
            </summary>
            <param name="userID">identificador del admin que se busca obtener</param>
            <returns>Retorna true si encuentra alguna coicidencia con el identificador
             pasado, devuelve false si no encuentra coicidencia</returns>
        </member>
        <member name="M:ClassLibrary.Database.ExistWorker(System.Int64)">
            <summary>
            Busca si hay algún worker que concida con ese identificador
            </summary>
            <param name="userID">identificador del worker que se busca obtener</param>
            <returns>Retorna true si encuentra alguna coicidencia con el identificador
             pasado, devuelve false si no encuentra coicidencia</returns>
        </member>
        <member name="M:ClassLibrary.Database.ExistEmployer(System.Int64)">
            <summary>
            Busca si hay algún employer que concida con ese identificador
            </summary>
            <param name="userID">identificador del employer que se busca obtener</param>
            <returns>Retorna true si encuentra alguna coicidencia con el identificador
             pasado, devuelve false si no encuentra coicidencia</returns>
        </member>
        <member name="M:ClassLibrary.Database.ExistWorkOffer(System.Int32)">
            <summary>
            Se encarga de revisar si existe una oferta de trabajo con ese identificador
            </summary>
            <param name="identify"></param>
            <returns>True si existe una workOffer con ese identificador o false si no existe</returns>
        </member>
        <member name="M:ClassLibrary.Database.MatachWorkOffer(System.String,System.String,System.Int32,System.Int64,System.Collections.Generic.List{System.String},System.Int32)">
            <summary>
            Se encarga de revisar si existe una coicidencia para una oferta de trabajo que sea igual, así 
            sabremos si ya esta en el sistema o si no existe tal oferta. Esto debido a que al ser el identify un autoincrementable, 
            puede ocurrír que se ingrese dos veces la misma información
            </summary>
            <param name="description">Descripción de la oferta a buscar</param>
            <param name="currency">Moneda de la oferta a buscar</param>
            <param name="price">Precio de la oferta</param>
            <param name="ownerID">Identificador del dueño</param>
            <param name="inputCategories">Categorías que tiene la oferta a buscar</param>
            <param name="durationInDays">Duración en días de la oferta</param>
            <returns></returns>
        </member>
        <member name="M:ClassLibrary.Database.SearchWorkOffer(System.Int32)">
            <summary>
            Se encarga de devolver el objeto que este en la lista de ofertas de trabajo si es que hay alguno que 
            tenga el mismo identify que el que se recibe por parametros. 
            </summary>
            <param name="identify"></param>
            <returns>El objeto workOffer si es que hay uno, o null si no econtró nada</returns>
        </member>
        <member name="M:ClassLibrary.Database.SearchWorker(System.Int64)">
            <summary>
            Se encarga de devolver el objeto worker que corresponde al userID pasado
            </summary>
            <param name="workerID"></param>
            <returns>Devuelve el objeto si existe un worker con ese userID, si no existe devuelve null</returns>
        </member>
        <member name="M:ClassLibrary.Database.SearchEmployer(System.Int64)">
            <summary>
            Se encarga de devolver el objeto employer que corresponde al userID pasado
            </summary>
            <param name="employerID"></param>
            <returns>Devuelve el objeto si existe un employer con ese userID, si no existe devuelve null</returns>
        </member>
        <member name="T:ClassLibrary.Employer">
            <summary>
            Clase que modela al rol de Empleador en el bot.
            La clase employer cumple con Expert al igual que la clase User, ya que es la encargada de conocer
            los atributos de sus instancias únicamente. En caso de necesitar saber la ubicación, necesita llamar
            a la clase Location, ya que es la experta en eso.
            Tenemos que el constructor de la clase es el que hace el registro del usuario.
            Como los usuarios van a ser diferentes del administrador, por que van a tener datos personales
            que sirven para las funcinalidades del programa, implementamos la clase padre y en la clase hija 
            le enviamos los datos necesarios para construir el objeto. Utilizamos herencia en función de lograr 
            una reutilización del código.
            </summary>
        </member>
        <member name="M:ClassLibrary.Employer.#ctor(System.Int64,System.String,System.String,System.String,System.String,System.Double,System.Double)">
            <summary>
            Constructor de la clase Employer. Le pasa los datos al constructor de la clase padre.
            </summary>
            <param name="userID">Identificador de telegram</param>
            <param name="name">Nombre del empleador</param>
            <param name="lastName">Apellido del empleador</param>
            <param name="phone">Número de celular del empleador</param>
            <param name="address">Dirección del empleador</param>
            <param name="latitude">Coordenada correspondiente a la latitud de la dirección del empleador</param>
            <param name="longitude">Coordenada correspondiente a la longitud de la dirección del empleador</param>
        </member>
        <member name="T:ClassLibrary.LocationUser">
            <summary>
            Clase encargada por Expert de conocer los datos de la ubicación del usuario.
            Por otro lado es un componente de la clase User, ya que no hay motivos para que esta información exista sin 
            estar ligada a un usuario, al menos en este contexto.
            </summary>
        </member>
        <member name="P:ClassLibrary.LocationUser.FormatAddress">
            <summary>
            Dirección con un formato, como Av. 8 de Octubre 2121
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.LocationUser.Latitude">
            <summary>
            Coordenada de la latitud de la ubicación del usuario
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.LocationUser.Longitude">
            <summary>
            Coordenada de la longitud de la ubicación del usuario
            </summary>
            <value></value>
        </member>
        <member name="M:ClassLibrary.LocationUser.#ctor(System.String,System.Double,System.Double)">
            <summary>
            Crea la locación o ubicación para poder saber donde esta ese usuario en un mapa,
            para así poder tomar decisiones en base a cuan lejos esta el trabajador del empleador. 
            </summary>
            <param name="formatAddress"></param>
            <param name="latitude"></param>
            <param name="longitude"></param>
            <returns></returns>
        </member>
        <member name="T:ClassLibrary.Notification">
            <summary>
            Esta clase viene a representar las notificaciones que recibe un user en su sección o chat. 
            Se creo cumpliendo con el patrón de Delegación y Composición, por que se separon los datos en 
            otro objeto cuando pudieron estar en la clase user, terminando esta en ser un componente de user.
            Además se cumple dos condiciones para este patrón, que la clase User tiene una lista de objetos de este tipo y que
            no tiene sentido que exista esta clase sin estar ligada a un usuario, al menos en este contexto. 
            </summary>
        </member>
        <member name="P:ClassLibrary.Notification.NotificationReasons">
            <summary>
            Motivo o asunto de la notificación
            </summary>
            <value></value>
        </member>
        <member name="T:ClassLibrary.Notification.Reasons">
            <summary>
             Representa los posibles motivos por lo que se le notifico algo al user
            </summary>
        </member>
        <member name="F:ClassLibrary.Notification.Reasons.EmployerWantContactWorker">
            Para cuando se crea una notificación de los que un employer se quiere contactar cono un worker
        </member>
        <member name="F:ClassLibrary.Notification.Reasons.WorkerResponseAnEmployer">
            Para cuando el worker le response al employer
        </member>
        <member name="F:ClassLibrary.Notification.Reasons.AdminDeleteWorkOffer">
            Para cuando el admin le borra una work offer al worker y se le genera una notificación
        </member>
        <member name="P:ClassLibrary.Notification.NotificationID">
            <summary>
            Identificador de la notificación, para hacer que una sea diferente de otra
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.Notification.Message">
            <summary>
            Mensaje que se le va a mostrar al user
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.Notification.SenderID">
            <summary>
            Identificador del usuario que le genero una notificación
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.Notification.CreationDate">
            <summary>
            Fecha de creación o cuando se produjo la notificación
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.Notification.IsOpen">
            <summary>
            Para controlar las notificaciones que estan "abiertas" 
            o que todavía no se cerraron
            </summary>
            <value></value>
        </member>
        <member name="M:ClassLibrary.Notification.#ctor(System.String,System.Int64,System.Int32,ClassLibrary.Notification.Reasons)">
            <summary>
            Constructor de la notificación, la forma de que un user se entere de cosas, como de las intenciones de 
            comunicarse de un employer (si es que eres un worker), o sobre la respuesta de un worker 
            al querer contactarlo si eres un employer. 
            </summary>
            <param name="message">Texto que se le va a mostar al user</param>
            <param name="senderID">UserID del que le genero la notificación</param>
            <param name="notificationID">Identificador único para este objeto, así se diferencia de otros objetos del mismo tipo</param>
            <param name="reasons">Asunto o motivo de la notificación</param>
        </member>
        <member name="M:ClassLibrary.Notification.CloseNotifcation">
            <summary>
            Para mantener encapsulado el cerrar la notificación
            </summary>
        </member>
        <member name="T:ClassLibrary.Profile">
            <summary>
            Clase que se encarga de conocer un dato común entre todos los usuarios.
            Esta clase cumple con el principio Expert pues es la experta en conocer el identificador de usuario proveído por Telegram
            </summary>
        </member>
        <member name="P:ClassLibrary.Profile.UserID">
            <summary>
             Propiedad que representa al ID de los usuarios que llegan al bot
            </summary>
            <value> Será dado por el resto de componentes del bot</value>
        </member>
        <member name="M:ClassLibrary.Profile.#ctor(System.Int64)">
            <summary>
            Hacemos que el constructor sea protected porque no queremos que 
            se creen instancias de este objeto. 
            </summary>
            <param name="userID"> ID de la plataforma que usa nuestro bot</param>
        </member>
        <member name="T:ClassLibrary.Rating">
            <summary>
            Esta clase se diseño pensando en Composición y Delegación, ya que debiamos de tener varias calificaciones 
            para poder hacer el promedio, pero si todo eso quedaba cargado en la clase User, sumando el hecho de contar con notificaciones
             y un objeto LocationUser, le daríamos más de una razón para cambiar (si cambiese la forma de notificar y la de calificar por ejemplo). 
            Así que se cumple con SRP y también se cumple con Expert, ya que para saber la información de una calificación, 
            deben entrar a la clase Rating, que es la experta en el área.
            </summary>
        </member>
        <member name="P:ClassLibrary.Rating.Rate">
            <summary>
            Valor númerico de una calificación
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.Rating.StartCountAMonth">
            <summary>
            Marca el tiempo momento en el que un worker puede puntuar al employer y viceversa, una vez que 
            se ven relacionados por un contacto afirmativo.
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.Rating.CalificatorID">
            <summary>
            Identificador de Telegram del usuario que califica o que crea esta calificación
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.Rating.WorkOfferID">
            <summary>
            Como las calificaciones se hacen sobre una oferta de trabajo, guardamos el identify de la oferta para 
            poder diferenciar esta de otra calificación, en la que estén el mismo employer contratante y al worker dueño
            </summary>
            <value></value>
        </member>
        <member name="M:ClassLibrary.Rating.#ctor(System.Int64,System.Int32,System.Int32)">
            <summary>
            Constructor de la calificación, crea e objeto con los datos necesarios para luego hacer el proceso de calificación
            </summary>
            <param name="calificatorID">Id del user que califica</param>
            <param name="durationWorkOffer">Duración de la oferta para hacer el cálculo de cuando arranca a contar el mes</param>
            <param name="workOfferID">Identificador de la oferta para poder saber sobre que trabajo se esta calificando al user en cuestión</param>
        </member>
        <member name="M:ClassLibrary.Rating.UpdateRate(System.Int32,System.Boolean)">
            <summary>
            Este método se encarga de realizar el proceso de calificación, si es un período de tiempo válido permite que se cambie ese valor 
            de puntuación que por defecto se carga en 0. 
            </summary>
            <param name="newRate">Puntuación que se va a otorgar</param>
            <param name="simulateDate">Bandera que sirve para simular que ya estamos en un momento valido para calificar; solo se usa en los test</param>
        </member>
        <member name="T:ClassLibrary.User">
            <summary>
            Esta clase cumple con el principio SRP, ya que su única responsabilidad es conocer los atributos de un usuario, teniendo las responsabilidades de conocer 
            la puntuación, la ubicación, y lo necesario de una notificación a otras clases, para así no violar dicho principio.
            También cumple con Expert, ya que se ocupa de saber las características que le toca y operar con ellas únicamente. 
            Por ejemplo, si necesitara saber la ubicación de un usuario, tiene que llamar a la clase Location, ya que ella no es la experta en eso.
            También cumple con el patrón Creator, ya que al recibir todos los datos de la ubicación, los datos de una notificación y una calificación, es capaz 
            de crear objetos de este tipo. Además cumple con la condición de tener un objeto de ese tipo (LocationUser), así como con la condición de contener a
            instancias de las clases que terminan siendo componentes. 
            </summary>
        </member>
        <member name="P:ClassLibrary.User.Name">
            <summary>
            Nombre del usuario
            </summary>
            <value>String que se le especifique como nombre</value>
        </member>
        <member name="P:ClassLibrary.User.LastName">
            <summary>
            Apellido del usuario
            </summary>
            <value>String que se le especifique como apellido</value>
        </member>
        <member name="P:ClassLibrary.User.Phone">
            <summary>
            Número de celular del usuario
            </summary>
            <value>String que se le especifique como número de celular</value>
        </member>
        <member name="P:ClassLibrary.User.Location">
            <summary>
            Objeto que guarda los datos de la ubicación del usuario
            </summary>
            <value>Instancia de la clase LocationUser</value>
        </member>
        <member name="P:ClassLibrary.User.Ratings">
            <summary>
            Lista de calificaciones del usuario
            </summary>
        </member>
        <member name="P:ClassLibrary.User.Notifications">
            <summary>
            Lista de notificaciones del usuario
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.User.UltimateIDNotification">
            <summary>
            Al igual que con las workOffer para tener un id para identificar una notificación de otra.
            </summary>
            <value></value>
        </member>
        <member name="M:ClassLibrary.User.#ctor(System.Int64,System.String,System.String,System.String,System.String,System.Double,System.Double)">
            <summary>
            Tenemos que el constructor de la clase es el que hacae el registro del usuario.
            Como los usuarios van a ser diferentes del administrador, por que van a tener datos personales
            que sirven para las funcinalidades del programa, implementamos la clase padre y en la clase hija 
            le enviamos los datos necesarios para construir el objeto. 
            </summary>
            <param name="userID">Identificador de telegram</param>
            <param name="name">Nombre del usuario</param>
            <param name="lastName">Apellido del usuario</param>
            <param name="phone">Número de celular del usuario</param>
            <param name="formatAddress">Dirección del usuario</param>
            <param name="latitude">Coordenada correspondiente a la latitud de la dirección del usuario</param>
            <param name="longitude">Coordenada correspondiente a la longitud de la dirección del usuario</param>
        </member>
        <member name="M:ClassLibrary.User.AddNotification(System.String,System.Int64,ClassLibrary.Notification.Reasons)">
            <summary>
            Este método se encarga de crear una notificación (siguiendo con el patrón Creator), y de añadirla a la lista de notificaciones.
            Decimos que cumple porque al tener una lista de instancias de esta clase, le corresponde recibir los datos necesarios para crear 
            instancias de dicha clase. 
            </summary>
            <param name="message">Mensaje que recibe el user</param>
            <param name="senderID">Identificador del que le genero la notificación</param>
            <param name="reasons">Asunto de la notificación</param>
        </member>
        <member name="M:ClassLibrary.User.CloseNotifcation(System.Int32)">
            <summary>
            Se encarga de dar por cerrada la notificación en cuestión, así no le aparece más al user
            </summary>
            <param name="notificationID"></param>
        </member>
        <member name="M:ClassLibrary.User.ReciveCalification(System.Int32,System.Int64,System.Int32,System.Boolean)">
            <summary>
            Se encarga de recibir la calificación que le otorga otro user.
            </summary>
            <param name="rate">puntaje</param>
            <param name="calificatorID">puntuado</param>
            <param name="workOfferID">la workoffer por la que se puntúa</param>
            <param name="simulateDate">Se usara para los test, para poder simular que estas en un día habil para calificar</param>
            <returns>Devuleve un mensaje de confirmación</returns>
        </member>
        <member name="M:ClassLibrary.User.GetNotifications">
            <summary>
            Método que devuelve la lista de notificaciones del usuario pero con la restricción de
            que son de solo lectura, preservando la integridad de dichos datos.
            </summary>
            <returns> Convierte el stringbuilder en string </returns>
        </member>
        <member name="M:ClassLibrary.User.AddRating(System.Int64,System.Int32,System.Int32)">
            <summary>
            En este método, recibe como parámetro lo necesario para crear un nuevo objeto de la clase Rating.
            Por patrón Creator, debido a que es el encargado a almacenarlo, este objeto crea la Rating.
            </summary>
            <param name="calificatorID">Quien calificó</param>
            <param name="durationWorkOffer">Duración de la oferta</param>
            <param name="workOfferID">Identificador de sobre que oferta se esta haciendo la calificación</param>
        </member>
        <member name="M:ClassLibrary.User.GetRating">
            <summary>
            Devuelve el resultado de la cuenta de promediar las calificaciones del Usuario
            </summary>
            <returns></returns>
        </member>
        <member name="T:ClassLibrary.Worker">
            <summary>
            Clase que modela al rol de Trabajador en el bot.
            La clase Worker cumple con Expert al igual que la clase User, ya que es la encargada de conocer
            los atributos de sus instancias únicamente. En caso de necesitar saber la ubicación, necesita llamar
            a la clase Location, ya que es la experta en eso. 
            Tenemos que el constructor de la clase es el que hace el registro del usuario.
            Como los usuarios van a ser diferentes del administrador, por que van a tener datos personales
            que sirven para las funcinalidades del programa, implementamos la clase padre y en la clase hija 
            le enviamos los datos necesarios para construir el objeto. Utilizamos herencia en función de lograr 
            una reutilización del código.
            </summary>
        </member>
        <member name="M:ClassLibrary.Worker.#ctor(System.Int64,System.String,System.String,System.String,System.String,System.Double,System.Double)">
            <summary>
            Constructor de la clase Worker. Le pasa los datos al constructor de la clase padre.
            </summary>
            <param name="userID">Identificador de telegram</param>
            <param name="name">Nombre del trabajador</param>
            <param name="lastName">Apellido del trabajador</param>
            <param name="phone">Número de celular del trabajador</param>
            <param name="address">Dirección del trabajador</param>
            <param name="latitude">Coordenada correspondiente a la latitud de la dirección del trabajador</param>
            <param name="longitude">Coordenada correspondiente a la longitud de la dirección del trabajador</param>
        </member>
        <member name="M:ClassLibrary.Worker.Update(System.String)">
            <summary>
            Aplicando el patrón Observer establecimos que el tipo Worker debería ser un Subscriptor de las ofertas de trabajo, para así 
            en vez de estar pregutando o revisando cada cierto tiempo en que estado esta su oferta, se le avisa cuando esta es dada de baja
            por un administrador. Este método se encarga de recibir el mensaje cuando se da la alerta o notificación del lado del objeto observado, y 
            crea un objeto de tipo Notification que se le agrega a la lista de notificaciones del trabajador.
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:ClassLibrary.WorkOffer">
            <summary>
            Clase creada para representar a una oferta de trabajo siguiendo el principio de Expert, puesto que 
            es la experta en todo lo que tiene que ver a los datos de una oferta de trabajo, en este contexto. 
            </summary>
        </member>
        <member name="P:ClassLibrary.WorkOffer.Identify">
            <summary>
            Identificador dado por la base de datos a la oferta, con tal de hacerla distinta de otras
            </summary>
            <value>Int correspondiente al identificador</value>
        </member>
        <member name="P:ClassLibrary.WorkOffer.Description">
            <summary>
            Descripción dada por el worker que la crea
            </summary>
            <value>String que corresponde a la descripción dada por su creador</value>
        </member>
        <member name="P:ClassLibrary.WorkOffer.Currency">
            <summary>
            Esta propiedad se refiere a la moneda que tendría el precio de la oferta.
            </summary>
            <value>String que contiene el simbolo o simbolos de la moneda a usar</value>
        </member>
        <member name="P:ClassLibrary.WorkOffer.Price">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.WorkOffer.OwnerWorkerID">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.WorkOffer.IsPublished">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.WorkOffer.DurationInDays">
            <summary>
            Esta propiedad se refiere a cuanto aproximadamente sería el trabajo o de por cuanto sería tiempo
            sería el trabajo.
            </summary>
            <value>Valor de cuantos días dura el trabajo o servicio en particular</value>
        </member>
        <member name="P:ClassLibrary.WorkOffer.Observers">
            <summary>
            Guardamos los observadores que puede llegar a tener un objeto de este tipo.
            </summary>
            <value></value>
            
        </member>
        <member name="F:ClassLibrary.WorkOffer.categories">
            <summary>
            Almacenamos a que categorías pertenece la oferta 
            </summary>
        </member>
        <member name="M:ClassLibrary.WorkOffer.#ctor(System.Int32,System.String,System.String,System.Int32,System.Int64,System.Collections.Generic.List{System.String},System.Int32)">
            <summary>
             Constructor encargado de crear la oferta de trabajo
            </summary>
            <param name="identify">Identificador único dado por la base de datos</param>
            <param name="description">Descripción dada por el worker que la crea</param>
            <param name="currency">Moneda que tendrá la oferta, habiendo cuatro simolos validos USD, UYU, $U, U$S</param>
            <param name="price">Precio que tendrá la oferta</param>
            <param name="ownerWorkerID">Identificador del dueño</param>
            <param name="categories">Lista de categorías que tendrá la oferta</param>
            <param name="durationInDays">Duración del trabajo en días</param>    
        </member>
        <member name="M:ClassLibrary.WorkOffer.AddObserver(ClassLibrary.IObserver)">
            <summary>
            Agrega un subscriptor a recibir una notificación por el cambio que se espera manejar, 
            siguiendo con lo pactado en el patrón Observer
            </summary>
            <param name="observer"></param>
        </member>
        <member name="M:ClassLibrary.WorkOffer.RemoveObserver(ClassLibrary.IObserver)">
            <summary>
            Elimina un subscriptor de la lista de los que querían recibir
            una notificación por el cambio que se espera manejar. 
            Esto se hace siguiendo el patrón Observer
            </summary>
            <param name="observer"></param>
        </member>
        <member name="M:ClassLibrary.WorkOffer.Notify">
            <summary>
            Método asociados al patrón de diseño Observer. Encargado de notificar al usuario si su oferta fue eliminada.
            </summary>
        </member>
        <member name="M:ClassLibrary.WorkOffer.Delete">
            <summary>
            Método que elimina una oferta y dado el patrón Observer, notifica a sus subscriptores.
            </summary>
        </member>
        <member name="M:ClassLibrary.WorkOffer.GetCateogories">
            <summary>
            Devulve las categorías de la oferta de trabajo, como una lista de solo lectura
            </summary>
            <returns>Lista de solo lectura</returns>
        </member>
        <member name="T:ClassLibrary.FilterByCategory">
            <summary>
            Filtro concreto que excluye las ofertas de trabajo que no tienen la categoría pasada en su método Filter
            Filtro concreto de las ofertas en base a la categoría de las ofertas de trabajo, quedando solamente las que tengan al menos la categoría especificada.
            Cumple con el principio de inversión de dependencias (DIP), ya que esta clase depende de una interfaz
            (IFilter), de la cual depende el comando SearchFilteredWorkOfferCommand que es una clase concreta. Al cumplir con DIP
            también se cumple con LSP puesto que se puede sustituir por cualquier otra clase que también implemente el tipo IFilter. 
            Con esto también podemos decir que se rige bajo Polimorfismo, ya que se puede cambiar el comportamiento de cada método en el subtipo, 
            estando definida la firma del método en el supertipo. 
            </summary>
        </member>
        <member name="P:ClassLibrary.FilterByCategory.Name">
            <summary>
            Es el nombre que tendrá el filtro y que lo diferenciará de otros filtros
            </summary>
            <value>El nombre que se le especifique</value>
        </member>
        <member name="P:ClassLibrary.FilterByCategory.MessageForFilter">
            <summary>
            Mensaje se que se devuelve por filtro, para que el usuario sepa que información ingresar
            </summary>
            <value></value>
        </member>
        <member name="M:ClassLibrary.FilterByCategory.#ctor">
            <summary>
            Se encarga de asignarle un valor a la propiedad del nombre con el fin
            de diferenciar entre un filtro y otro
            </summary>
        </member>
        <member name="M:ClassLibrary.FilterByCategory.Fiilter(System.String)">
            <summary>
            Operación polimorfica encargada de filtrar  las ofertas por su categoría (en este caso), excluyendo las que no 
            tengan en su lista a la categoría especificada. 
            /// </summary>
            <param name="nameCategory">Nombre de la categoría que se va a usar </param>
            <returns> Retornara un mensjae con los resultados obtenidos de los filtros</returns>
        </member>
        <member name="T:ClassLibrary.Format">
            <summary>
            Clase usada para reutilizar el código de formatear entradas de texto. Quitando tildes, poniendo el texto en mayúsculas o minúsculas, 
            al par que quita los espacios en blanco del principio y el final de la palabra. 
            </summary>
        </member>
        <member name="M:ClassLibrary.Format.RemoveAcentMarkToUpper(System.String)">
            <summary>
            Método que se encarga de formatear el texto para que quede todo en mayus y sacandole los tildes 
            que pueda llegar a tener
            </summary>
            <param name="word"></param>
            <returns></returns>
        </member>
        <member name="M:ClassLibrary.Format.RemoveAcentMarkToLower(System.String)">
            <summary>
            Método que se encarga de formatear el texto para que quede todo en mayus y sacandole los tildes 
            que pueda llegar a tener
            </summary>
            <param name="word"></param>
            <returns></returns>
        </member>
        <member name="T:ClassLibrary.AddressFinder">
            <summary>
            Un buscador de direcciones concreto que usa una API de localización.
            Cumple con el principio de inversión de dependencias, por que esta clase depende de una abstracción 
            y las clases que la usan, definen el tipo como IAddressFinder, cumpliendo a su vez con LSP, puesto que en tiempo
            de ejecución se puede definir que buscar contreto usar. A su vez, cumple con Polimorfismo, ya que cada buscador
            implementará los métodos como más le resulte conveniente.
            </summary>
        </member>
        <member name="M:ClassLibrary.AddressFinder.#ctor(Ucu.Poo.Locations.Client.LocationApiClient)">
            <summary>
            Inicializa una nueva instancia de AddressFinder.
            </summary>
            <param name="client">El cliente de la API de localización.</param>
        </member>
        <member name="M:ClassLibrary.AddressFinder.GetLocation(System.String)">
            <summary>
            Determina si existe una dirección.
            </summary>
            <param name="address">La dirección a buscar.</param>
            <returns>Una instancia de AddressResult con el resultado de la búsqueda, que incluye si la dirección se
            encontró o no, y si se encontró, la latitud y la longitud de la dirección.</returns>
        </member>
        <member name="T:ClassLibrary.AddressResult">
            <summary>
            Una implementación concreta del resutlado de buscar una dirección. Además de las propiedades definidas en
            IAddressResult esta clase agrega una propiedad Location para acceder a las coordenadas de la dirección buscada.
            Cumple con DIP ya que depende de una abstracción y las clases que la usen dependerán de la abstracción y no de ella.
            Polirfismo se aplica al tener que cada clase concreta implementa de la forma que más le sirva cada método definido en 
            el tipo IAddressResult. 
            </summary>
        </member>
        <member name="P:ClassLibrary.AddressResult.Found">
            <summary>
            Propiedad que indica si se encontró algún lugar o si no se hayo nada
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.AddressResult.Latitude">
            <summary>
            Propiedad correspondiente al dato latitud que devuelve la búsqueda
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.AddressResult.Longitude">
            <summary>
            Propiedad correspondiente al dato longitud que devuelve la búsqueda
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.AddressResult.Location">
            <summary>
            Guarda una instancia de la clase Location con los datos proporicionados por la API
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.AddressResult.FormatAddress">
            <summary>
            Se encarga de devolver la dirección  completa.
            </summary>
            <value></value>
        </member>
        <member name="M:ClassLibrary.AddressResult.#ctor(Ucu.Poo.Locations.Client.Location)">
            <summary>
            Constructor de la clase 
            </summary>
            <param name="location"></param>
        </member>
        <member name="T:ClassLibrary.DistanceCalculator">
            <summary>
            Un calculador de distancias concreto que utiliza una API de localización para calcular la distancia entre dos
            direcciones. Cumple con DIP ya que depende de una abstracción y no de una clase concreta, además cuando se haga uso, primero 
            se va definir el tipo de la variable como IDistanceCalculator, pudiendo luego usarse cualquiera que se requiera mientras corre el 
            programa. Esto último a su ve permite que se cumpla con LSP. 
            </summary>
        </member>
        <member name="M:ClassLibrary.DistanceCalculator.#ctor(Ucu.Poo.Locations.Client.LocationApiClient)">
            <summary>
            Constructor de la clase 
            </summary>
            <param name="client">Instancia de la clase LocationApiCliente</param>
        </member>
        <member name="M:ClassLibrary.DistanceCalculator.CalculateDistance(System.String,System.String)">
            <summary>
            Se encarga de calcular la disntacia y devolver un objeto IDistanceResult, que tiene toda la información sobre 
            el cálculo
            </summary>
            <param name="fromAddress">Dirección de inicio o punto de partida</param>
            <param name="toAddress">Dirección de fin o punto de finalización de un camino</param>
            <returns></returns>
        </member>
        <member name="T:ClassLibrary.DistanceResult">
            <summary>
            Una implementación concreta del resutlado de calcular distancias. Además de las propiedades definidas en
            IDistanceResult esta clase agrega propiedades para acceder a las coordenadas de las direcciones buscadas.
            </summary>
        </member>
        <member name="P:ClassLibrary.DistanceResult.FromExists">
            <summary>
            Propiedad que almacena si existe la dirección de origen
            </summary>
            <value>True si existe, false si no existe</value>
        </member>
        <member name="P:ClassLibrary.DistanceResult.ToExists">
            <summary>
            Propiedad que almacena si existe la dirección de destino
            </summary>
            <value>True si existe, false si no existe</value>
        </member>
        <member name="P:ClassLibrary.DistanceResult.Distance">
            <summary>
            Propiedad que almacena el resultado del cálculo de distancia
            </summary>
            <value>True si existe, false si no existe</value>
        </member>
        <member name="M:ClassLibrary.DistanceResult.#ctor(Ucu.Poo.Locations.Client.Location,Ucu.Poo.Locations.Client.Location,System.Double,System.Double)">
            <summary>
            Inicializa una nueva instancia de DistanceResult a partir de dos coordenadas, la distancia y el tiempo
            entre ellas.
            </summary>
            <param name="from">Las coordenadas de origen.</param>
            <param name="to">Las coordenadas de destino.</param>
            <param name="distance">La distancia entre las coordenadas.</param>
            <param name="time">El tiempo que se demora en llegar del origen al destino.</param>
        </member>
        <member name="T:ClassLibrary.IAddressFinder">
            <summary>
            Una interfaz define una abstracción para un buscador de direcciones genérico.
            </summary>
            <remarks>
            Esta interfaz fue creada siguiendo el principio de inversión de dependencias para evitar que los comandos
            concretos dependan de buscadores de direcciones concretos; en su lugar los comandos concretos dependen de esta
            abstracción.
            Entre otras cosas est permite cambiar el buscador de direcciones en tiempo de ejecución, para utilizar uno en
            los casos de prueba que retorna resultados conocidos para direcciones conocidas, y otro en la versión final para
            buscar usando una API de localizaciones.
            </remarks>
        </member>
        <member name="M:ClassLibrary.IAddressFinder.GetLocation(System.String)">
            <summary>
            Determina si existe una dirección.
            </summary>
            <param name="address">La dirección a buscar.</param>
            <returns>Un objeto de una clase que implemente la interfaz IAddressResult con el resultado de la búsqueda, que
            incluye si la dirección se encontró o no, y si se encontró, la latitud y la longitud de la dirección.</returns>
        </member>
        <member name="T:ClassLibrary.IAddressResult">
            <summary>
            Interfaz que representa la abstracción de los resultados de la búsqueda. Cumple con DIP ya que no se va a depender de una clase concreta
            sino de esta abstracción que será implementada por al menos una clase concreta. Al poder sustituirse en tiempo de ejecución
            por cualquier clase concreta que implemente el tipo también cumple con LSP.
            </summary>
        </member>
        <member name="P:ClassLibrary.IAddressResult.Found">
            <summary>
            Indica si se encontró o no la dirección. En ese caso son válidos los demás valores. En caso contrario los
            demás valores son indeterminados.
            </summary>
            <value>true si se encontró la dirección; false en caso contrario.</value>
        </member>
        <member name="P:ClassLibrary.IAddressResult.Latitude">
            <summary>
            La latitud de la dirección.
            </summary>
            <value>El valor de la latitud en formato decimal.</value>
        </member>
        <member name="P:ClassLibrary.IAddressResult.Longitude">
            <summary>
            La longitud de la dirección.
            </summary>
            <value>El valor de la longitud en formato decimal.</value>
        </member>
        <member name="P:ClassLibrary.IAddressResult.FormatAddress">
            <summary>
            Dirección con formato normal, como por ejemplo Av. 8 de Octubre 2012
            </summary>
            <value></value>
        </member>
        <member name="T:ClassLibrary.IDistanceCalculator">
            <summary>
            Una interfaz que define una abstracción para un calculador de distancias genérico.
            </summary>
            <remarks>
            Esta interfaz fue creada siguiendo el principio de inversión de dependencias para evitar que los comandos
            concretos dependan de calculadores de distancias concretos; en su lugar los comandos concretos dependen de esta
            abstracción.
            Entre otras cosas est permite cambiar el calculador de distancias en tiempo de ejecución, para utilizar uno en
            los casos de prueba que retorna resultados conocidos para direcciones conocidas, y otro en la versión final para
            buscar usando una API de localizaciones.
            </remarks>
        </member>
        <member name="M:ClassLibrary.IDistanceCalculator.CalculateDistance(System.String,System.String)">
            <summary>
            Determina si existe una dirección.
            </summary>
            <param name="fromAddress">La dirección de origen para la distancia.</param>
            <param name="toAddress">La dirección de destino o punto final del trazo.</param>
            <returns>true si la dirección existe; false en caso contrario.</returns>
        </member>
        <member name="T:ClassLibrary.IDistanceResult">
            <summary>
            Una interfaz que define una abstracción para el resultado de calcular distancias.
            </summary>
        </member>
        <member name="P:ClassLibrary.IDistanceResult.FromExists">
            <summary>
            Obtiene un valor que indica si la dirección de origen para el cálculo de distancias existe; sólo se puede
            calcular la distancia entre direcciones que existen.
            </summary>
        </member>
        <member name="P:ClassLibrary.IDistanceResult.ToExists">
            <summary>
            Obtiene un valor que indica si la dirección de destino para el cálculo de distancias existe; sólo se puede
            calcular la distancia entre direcciones que existen.
            </summary>
        </member>
        <member name="P:ClassLibrary.IDistanceResult.Distance">
            <summary>
            La distancia calculada.
            </summary>
        </member>
        <member name="T:ClassLibrary.ICommand">
            <summary>
            Intefaz craeda bajo el principio DIP para que el interpretador de entradas no 
            dependa de una clase concreta y sea obligado a tener una dependencia indeseable. 
            Al seguir DIP en el marco de la ejecución del programa, yendo más precisamente al interpretador 
            de entradas (InputInterfacer), este puede hacer uso de cualquier comando que tenga como supertipo el tipo 
            ICommand, por lo cual se puede sustituir sin probocar cambios colaterales, cumpliendo de esta forma con LSP. 
            A su vez, al ser una abstracción implementada por varias clases abstractas, sus operaciones terminan siendo 
            polimorficas, puesto que cada una las implementa de la forma que más les convenga. 
            </summary>
        </member>
        <member name="P:ClassLibrary.ICommand.Name">
            <summary>
            Es el nombre que tendrá el comando y que lo diferenciará de otros comandos
            </summary>
            <value>El nombre que se le especifique</value>
        </member>
        <member name="P:ClassLibrary.ICommand.InProccess">
            <summary>
            Para que de afuera se pueda saber si se esta ejecutando o si ya termino su ejecución, para dejar libre el camino a otro
            </summary>
            <value>false si esta terminada la ejecución, true si todavía sigue en camino</value>
        </member>
        <member name="M:ClassLibrary.ICommand.Execute(System.Int64,System.String)">
            <summary>
            Operación  que se encarga de ejecutar la acción que le da su razón de ser al comando
            </summary>
            <param name="userID"> Identificador del usuario que ejecuta el comando</param>
            <param name="data"> Conjunto de datos ingresados o recibidos desde la interfaz, es lo que escribió el usuario</param>
            <returns> Devuleve o el resultado de una busqueda o filtro, o si se concreto correctamente la acción</returns>
        </member>
        <member name="M:ClassLibrary.ICommand.ProfileCanExecute(System.Int64)">
            <summary>
            Se encarga de verificar que el user de Telegram pueda usar este comando o no,
            en base a que es o que rol tiene en nuestro sistema.
            </summary>
            <param name="userID">Identificador de Telegram del usuario que ejecuto el comando</param>
            <returns>True si puede, false si no esta habilitado</returns>
        </member>
        <member name="M:ClassLibrary.ICommand.RestoreData(System.Int64)">
            <summary>
            Se restaura la información del user que esta usando el comando 
            </summary>
        </member>
        <member name="M:ClassLibrary.ICommand.Cancel(System.Int64)">
            <summary>
            Cancela la ejecución del comando y retorna un 
            mensaje diciendo el nombre del comando y que se cancelo. 
            </summary>
            <returns>Mensaje con el nombre del comando a modo de confirmación de que se 
            cancelo el comando</returns>
        </member>
        <member name="T:ClassLibrary.IFilter">
            <summary>
            Intefaz que usamos para abstraer el concepto de un Filtro. Además lo creamos para que una clase concreta, que es 
            SearchFilteredWorkOfferCommand, no dependa de un filtro en particular sino de cualquier filtro que quiera usarse. 
            Por tal motivo cumple con DIP.  A su vez, se cumple con LSP puesto que se en el programa se puede sustituir un ordenar
             por cualquier otro  que también implemente el tipo IFilter. Con esto también podemos decir que se rige bajo Polimorfismo,
             ya que en cada clase concreta (subtipo) se implementa un comportamiento especifico de ella, estando la firma
            definida en la interfaz (supertipo).  
            
            La forma de crearse fue siguiendo el principio de segragación de interfaces (ISP), puesto que en un inicio 
            teníamos una interfaz que especificaba las operaciones de buscar las ofertas y ordenarlas por ubicación,
            por puntuación así como de filtrarlas por la categoría. 
            Por ende, la clase que hiciera uso de esta abstracción iba a termiar dependiendo e implementando 
            operaciones que no le correspondían usar. Por tal motivo separamos las responsabilidades en filtros y ordenadores, 
            cada uno con una correspondiente interfaz, IFilter e ISort respectivamente. Siendo esta la resultante para la operación de filtrar.
            
            
            </summary>
        </member>
        <member name="P:ClassLibrary.IFilter.Name">
            <summary>
            Es el nombre que tendrá el filtro y que lo diferenciará de otros filtros
            </summary>
            <value>El nombre que se le especifique</value>
        </member>
        <member name="P:ClassLibrary.IFilter.MessageForFilter">
            <summary>
            Mensaje se que se devuelve por filtro, para que el usuario sepa que información ingresar
            </summary>
            <value></value>
        </member>
        <member name="M:ClassLibrary.IFilter.Fiilter(System.String)">
            <summary>
            Operación polimorfica que va a variar dependiendo de la clase concreta que lo implemente. De todas formas 
            se encarga de filtrar las ofertas de trabajo en base al criterio marcado para su existencia y devuelve un texto
            con la información filtrada. 
            </summary>
            <param name="criterion">Valor que se le pasará para poder hacer el filtro, ya sea un nombre, un precio u otra
            especie de dato. </param>
            <returns> Retornara una lista con los resultados obtenidos de los filtros</returns>
        </member>
        <member name="T:ClassLibrary.InputInterfacer">
            <summary>
            Clase encargada de recibir lo que el usario ingresa por teclado, interpretarlo y ejecutar un comando en base a lo recibido.
            También se encarga de contener todos los comandos que pueden usarse. En un futuro se aplicará la restricción por rol o por subtipo del tipo Profile
            </summary>
        </member>
        <member name="F:ClassLibrary.InputInterfacer.lastCommandByUser">
            <summary>
            Se guarda por usuario el comadno que esta ejecutando
            </summary>
            <returns></returns>
        </member>
        <member name="P:ClassLibrary.InputInterfacer.Instance">
            <summary>
            Property para hacer que input interfacer sea un Singleton
            </summary>
            <value></value>
        </member>
        <member name="M:ClassLibrary.InputInterfacer.#ctor">
            <summary>
            Constructor del objeto, se encarga de crear instancias de los comandos y almacenarlos, para luego poder usarlos. 
            </summary>
        </member>
        <member name="M:ClassLibrary.InputInterfacer.TranslateToCommand(System.Int64,System.String)">
            <summary>
            Método encargado de traducir la entrada de datos en un comando, para luego ser ejecutado
            </summary>
            <param name="userID"> Identificador de quien es el que ejecuto el comando</param>
            <param name="inputData">Los datos que llegan por la entrada o la interfaz gráfica</param>
            <returns>Devuleve el mensaje de confirmación del comando, el restulado de una busqueda o que no se encontro el comando especificado</returns>
        </member>
        <member name="T:ClassLibrary.IObservable">
            <summary>
             Interfaz que aplica el patrón Observer. En este caso es la parte
            del observable, de lo que se observa. siendo en nuestro caso las ofertas de trabajo, 
            y la propiedad que dispara la notificación de que sucedio algo es la de IsPublished, haciendo 
            referencia si se dio de baja una oferta o no. 
            </summary>
        </member>
        <member name="P:ClassLibrary.IObservable.Observers">
            <summary>
            Guardamos los observadores que puede llegar a tener un objeto de este tipo
            </summary>
            <value></value>
        </member>
        <member name="M:ClassLibrary.IObservable.AddObserver(ClassLibrary.IObserver)">
            <summary>
            Agrega un subscriptor a recibir una notificación por el cambio que se espera manejar.
            </summary>
            <param name="observer"></param>
        </member>
        <member name="M:ClassLibrary.IObservable.RemoveObserver(ClassLibrary.IObserver)">
            <summary>
            Elimina un subscriptor de la lista de los que querían recibir
            una notificación por el cambio que se espera manejar. 
            </summary>
            <param name="observer"></param>
        </member>
        <member name="M:ClassLibrary.IObservable.Notify">
            <summary>
            Método encargado de revisar que subscriptores hay y notificarlos sobre el cambio previsto
            </summary>
        </member>
        <member name="T:ClassLibrary.IObserver">
            <summary>
            Interfaz que aplica el patrón Observer, siendo esta interfaz la que implementan 
            los observadores, en este caso los workers. 
            </summary>
        </member>
        <member name="M:ClassLibrary.IObserver.Update(System.String)">
            <summary>
            Método por el cual se le da parte al observador de que sucedio un cambio en 
            el observable
            </summary>
            <param name="message">message que recibe el usuario</param>
        </member>
        <member name="T:ClassLibrary.ISort">
            <summary>
            Interfaz que representa la abstracción de las diferentes formas de ordenar las ofertas de trabajo.
            La forma de crearse fue siguiendo el principio de segragación de interfaces (ISP), puesto que en un inicio 
            teníamos una interfaz que especificaba las operaciones de buscar las ofertas y ordenarlas por ubicación,
            por puntuación así como de filtrarlas por la categoría. 
            Por ende, la clase que hiciera uso de esta abstracción iba a termiar dependiendo e implementando 
            operaciones que no le correspondían usar. Por tal motivo separamos las responsabilidades en filtros y ordenadores, 
            cada uno con una correspondiente interfaz, IFilter e ISort respectivamente. Siendo esta la resultante para la operación de ordenar.
            
            A su vez, cumple con el principio de inversión de dependencias (DIP), ya que las clases concrtas que ordenen dependerán de esta interfaz
            mientras que las clases que quieran usar esta funcionalidad de ordenar (los comandos), dependen de esta abstracción y no de una clase concreta en particular.
            También se cumple con LSP puesto que se en el programa se puede sustituir un ordenar por cualquier otro  que también implemente el tipo ISort. 
            Con esto también podemos decir que se rige bajo Polimorfismo, ya que en cada clase concreta (subtipo) se implementa un comportamiento especifico de ella, estando la firma
            definida en la interfaz (supertipo).  
            </summary>
        </member>
        <member name="P:ClassLibrary.ISort.Name">
            <summary>
            Es el nombre que tendrá el ordenardor y que lo diferenciará de otros ordenadores
            </summary>
            <value>El nombre que se le especifique</value>
        </member>
        <member name="M:ClassLibrary.ISort.Order(System.Int64)">
            <summary>
            Operación polimorfica que va a variar dependiendo de la clase concreta que lo implemente. De todas formas 
            se encarga de ordenar las ofertas de trabajo en base al criterio marcado para su existencia y devuelve un texto
            con la información ordeanda. 
            </summary>
            <param name="userID"> En algunos casos se requiere de la información del solicitante para poder hacer la ordenación, 
            como en el caso de la distancia</param>
            <returns>Como cada ordenador manejar información diferente, es el ordenador el encargado de armar el mensaje
             con los resultados del proceso de ordenación. Por eso devuelve un string</returns>
        </member>
        <member name="T:ClassLibrary.SortByDistance">
            <summary>
            Ordenador concreto que ordena en base a la distancia entre el trabajador que ejecuta el comando y cada dueño de las ofertas. Quedando primeras
            las ofertas con workers que se ubiquen más cerca del empleador.
            
            Cumple con el principio de inversión de dependencias (DIP), ya que esta clase depende de una interfaz
            (ISort), de la cual depende el comando SearchSortedWorkOfferCommand que es una clase concreta. Al cumplir con DIP
            también se cumple con LSP puesto que se puede sustituir por cualquier otra clase que también implemente el tipo ISort. 
            Con esto también podemos decir que se rige bajo Polimorfismo, ya que se puede cambiar el comportamiento de cada método en el subtipo, 
            estando definida la firma del método en el supertipo. 
            </summary>
        </member>
        <member name="P:ClassLibrary.SortByDistance.Name">
            <summary>
            Es el nombre que tendrá el ordenardor y que lo diferenciará de otros ordenadores
            </summary>
            <value>El nombre que se le especifique</value>
        </member>
        <member name="P:ClassLibrary.SortByDistance.Result">
            <summary>
            El resultado del cálculo de la distancia entre las direcciones ingresadas.
            </summary>
        </member>
        <member name="M:ClassLibrary.SortByDistance.#ctor(ClassLibrary.IDistanceCalculator)">
            <summary>
            </summary>
            <param name="calculator">Un calculador de distancias.</param>
        </member>
        <member name="P:ClassLibrary.SortByDistance.Faild">
            <summary>
            Propiedad que se usa para saber si ocurrió un fallo en el ordanamiento, ya sea que 
            alguna dirección no existía, o se haya perdido la conexión y los datos no hubiesen llegado a 
            destino de forma correcta. 
            </summary>
            <value></value>
        </member>
        <member name="P:ClassLibrary.SortByDistance.MessageFaild">
            <summary>
            Propiedad que aloja el mensaje de fallo, explicando que fallo
            </summary>
            <value></value>
        </member>
        <member name="M:ClassLibrary.SortByDistance.Order(System.Int64)">
            <summary>
            Operación polimorfica especificada en el tipo ISort. Se encarga de reacomodar la lista  
            de ofertas de trabajo, ordenandolas bajo el criterio de la ubicación que tiene su dueño. 
            Las ofertas que quedan primero son las que tienen un dueño más cercano al employer que ejecuta el comando.
            </summary>
            <param name="userID"> User</param>
            <returns> Retornará un string con todos los datos formateados de lo que ordeno</returns>
        </member>
        <member name="T:ClassLibrary.SortByRate">
            <summary>
            Ordenador concreto de las ofertas que ordena en base a la calificación del worker, quedando primero el de mejor calificación.
            Cumple con el principio de inversión de dependencias (DIP), ya que esta clase depende de una interfaz
            (ISort), de la cual depende el comando SearchSortedWorkOfferCommand que es una clase concreta. Al cumplir con DIP
            también se cumple con LSP puesto que se puede sustituir por cualquier otra clase que también implemente el tipo ISort. 
            Con esto también podemos decir que se rige bajo Polimorfismo, ya que se puede cambiar el comportamiento de cada método en el subtipo, 
            estando definida la firma del método en el supertipo. 
            </summary>
        </member>
        <member name="P:ClassLibrary.SortByRate.Name">
            <summary>
            Es el nombre que tendrá el ordenardor y que lo diferenciará de otros ordenadores
            </summary>
            <value>El nombre que se le especifique</value>
        </member>
        <member name="M:ClassLibrary.SortByRate.#ctor">
            <summary>
            Se encarga de cargar el nombre del ordenador
            </summary>
        </member>
        <member name="M:ClassLibrary.SortByRate.Order(System.Int64)">
            <summary>
            Operación polimorfica especificada en el tipo ISort. Se encarga de reacomodar la lista de 
            ofertas de trabajo, ordenandolas bajo el criterio de la calificación que tiene su dueño. 
            Las que tengan un dueño con calificación alta irán primero, quedando para lo último las que tengan dueños
            con una calificación mala o no tan buena en comparación con el resto. 
            </summary>
            <param name="userID"> User</param>
            <returns>Retorna un string con los datos de las ofertas que ordeno</returns>
        </member>
    </members>
</doc>
